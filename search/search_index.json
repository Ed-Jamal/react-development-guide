{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"React developer roadmap What should I learn as a React developer? Javascript Javascript ES6 best practices React design patterns and techniques Conditional in JSX Higher order comopnoents (Dependency Injection) Presentational vs container Decorators Event handlers Passing a function to setState Composition Vs. inheritance List components React anti-patterns Props in initial state setState() in componentWillMount() Mutating state Using indexes as Key Spreading props on DOM elements React performance tips shouldComponentUpdate() check Using Pure Components Using reselect React Unit/Integration tests Unit testing in React","title":"Home"},{"location":"anti-patterns/01/","text":"Props in Initial State From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created. Bad class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } } Good class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Props in Initial State"},{"location":"anti-patterns/01/#props-in-initial-state","text":"From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created.","title":"Props in Initial State"},{"location":"anti-patterns/01/#bad","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } }","title":"Bad"},{"location":"anti-patterns/01/#good","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Good"},{"location":"anti-patterns/02/","text":"setState() in componentWillMount() Avoid async initialization in componentWillMount() componentWillMount() is invoked immediately before mounting occurs. It is called before render() , therefore setting state in this method will not trigger a re-render. Avoid introducing any side-effects or subscriptions in this method. Make async calls for component initialization in componentDidMount instead of componentWillMount function componentDidMount() { axios.get(`api/messages`).then((result) => { const messages = result.data; console.log('COMPONENT WILL Mount messages : ', messages); this.setState({ messages: [...messages.content], }); }); }","title":"setState() in componentWillMount()"},{"location":"anti-patterns/02/#setstate-in-componentwillmount","text":"Avoid async initialization in componentWillMount() componentWillMount() is invoked immediately before mounting occurs. It is called before render() , therefore setting state in this method will not trigger a re-render. Avoid introducing any side-effects or subscriptions in this method. Make async calls for component initialization in componentDidMount instead of componentWillMount function componentDidMount() { axios.get(`api/messages`).then((result) => { const messages = result.data; console.log('COMPONENT WILL Mount messages : ', messages); this.setState({ messages: [...messages.content], }); }); }","title":"setState() in componentWillMount()"},{"location":"anti-patterns/03/","text":"Mutating State without setState() Causes state changes without making component re-render. Whenever setState gets called in future, the mutated state gets applied. Bad class SampleComponent extends Component { constructor(props) { super(props); this.state = { items: ['foo', 'bar'], }; this.handleClick = this.handleClick.bind(this); } handleClick() { // BAD: We mutate state here this.state.items.push('lorem'); this.setState({ items: this.state.items, }); } render() { return ( <div> {this.state.items.length} <button onClick={this.handleClick}>+</button> </div> ); } } Good class SampleComponent extends Component { constructor(props) { super(props); this.state = { items: ['foo', 'bar'], }; this.handleClick = this.handleClick.bind(this); } handleClick() { // We update using setState() - concat return new array after appending new item. this.setState((prevState) => ({ items: prevState.items.concat('lorem'), })); } render() { return ( <div> {this.state.items.length} <button onClick={this.handleClick}>+</button> </div> ); } }","title":"Mutating State without setState()"},{"location":"anti-patterns/03/#mutating-state-without-setstate","text":"Causes state changes without making component re-render. Whenever setState gets called in future, the mutated state gets applied.","title":"Mutating State without setState()"},{"location":"anti-patterns/03/#bad","text":"class SampleComponent extends Component { constructor(props) { super(props); this.state = { items: ['foo', 'bar'], }; this.handleClick = this.handleClick.bind(this); } handleClick() { // BAD: We mutate state here this.state.items.push('lorem'); this.setState({ items: this.state.items, }); } render() { return ( <div> {this.state.items.length} <button onClick={this.handleClick}>+</button> </div> ); } }","title":"Bad"},{"location":"anti-patterns/03/#good","text":"class SampleComponent extends Component { constructor(props) { super(props); this.state = { items: ['foo', 'bar'], }; this.handleClick = this.handleClick.bind(this); } handleClick() { // We update using setState() - concat return new array after appending new item. this.setState((prevState) => ({ items: prevState.items.concat('lorem'), })); } render() { return ( <div> {this.state.items.length} <button onClick={this.handleClick}>+</button> </div> ); } }","title":"Good"},{"location":"anti-patterns/04/","text":"Using indexes as keys Keys should be stable, predictable, and unique so that React can keep track of elements. Bad In this snippet each element's key will be based on ordering, rather than tied to the data that is being represented. This limits the optimizations that React can do. { todos.map((todo, index) => <Todo {...todo} key={index} />); } Good Assuming todo.id is unique to this list and stable, React would be able to reorder elements without needing to reevaluate them as much. { todos.map((todo) => <Todo {...todo} key={todo.id} />); }","title":"Using indexes as keys"},{"location":"anti-patterns/04/#using-indexes-as-keys","text":"Keys should be stable, predictable, and unique so that React can keep track of elements.","title":"Using indexes as keys"},{"location":"anti-patterns/04/#bad","text":"In this snippet each element's key will be based on ordering, rather than tied to the data that is being represented. This limits the optimizations that React can do. { todos.map((todo, index) => <Todo {...todo} key={index} />); }","title":"Bad"},{"location":"anti-patterns/04/#good","text":"Assuming todo.id is unique to this list and stable, React would be able to reorder elements without needing to reevaluate them as much. { todos.map((todo) => <Todo {...todo} key={todo.id} />); }","title":"Good"},{"location":"anti-patterns/05/","text":"Spreading props on DOM elements When we spread props we run into the risk of adding unknown HTML attributes, which is a bad practice. Bad This will try to add the unknown HTML attribute flag to the DOM element. const Sample = () => <Spread flag={true} className=\"content\" />; const Spread = (props) => <div {...props}>Test</div>; Good By creating props specifically for DOM attribute, we can safely spread. const Sample = () => <Spread flag={true} domProps={{ className: 'content' }} />; const Spread = (props) => <div {...props.domProps}>Test</div>; Or alternatively we can use prop destructuring with ...rest : const Sample = () => <Spread flag={true} className=\"content\" />; const Spread = ({ flag, ...domProps }) => <div {...domProps}>Test</div>;","title":"Spreading props on DOM elements"},{"location":"anti-patterns/05/#spreading-props-on-dom-elements","text":"When we spread props we run into the risk of adding unknown HTML attributes, which is a bad practice.","title":"Spreading props on DOM elements"},{"location":"anti-patterns/05/#bad","text":"This will try to add the unknown HTML attribute flag to the DOM element. const Sample = () => <Spread flag={true} className=\"content\" />; const Spread = (props) => <div {...props}>Test</div>;","title":"Bad"},{"location":"anti-patterns/05/#good","text":"By creating props specifically for DOM attribute, we can safely spread. const Sample = () => <Spread flag={true} domProps={{ className: 'content' }} />; const Spread = (props) => <div {...props.domProps}>Test</div>; Or alternatively we can use prop destructuring with ...rest : const Sample = () => <Spread flag={true} className=\"content\" />; const Spread = ({ flag, ...domProps }) => <div {...domProps}>Test</div>;","title":"Good"},{"location":"js/","text":"Javascript ES6 best practices Javascript ES6 best practices var versus let / const Replacing IIFEs with Blocks Arrow Functions Strings .includes( ) .repeat( ) Template Literals Destructuring Destructuring Arrays Destructuring Objects Modules Exporting in CommonJS Exporting in ES6 Importing in ES6 Parameters Default Parameters Rest Parameters Named Parameters Spread Operator Classes Symbols Symbol( ) Symbol.for(key) Maps WeakMaps Promises Generators Async Await Getter and setter functions var versus let / const Besides var , we now have access to two new identifiers for storing values \u2014 let and const . Unlike var , let and const statements are not hoisted to the top of their enclosing scope. An example of using var : var snack = 'Meow Mix'; function getFood(food) { if (food) { var snack = 'Friskies'; return snack; } return snack; } getFood(false); // undefined However, observe what happens when we replace var using let : let snack = 'Meow Mix'; function getFood(food) { if (food) { let snack = 'Friskies'; return snack; } return snack; } getFood(false); // 'Meow Mix' This change in behavior highlights that we need to be careful when refactoring legacy code which uses var . Blindly replacing instances of var with let may lead to unexpected behavior. Note : let and const are block scoped. Therefore, referencing block-scoped identifiers before they are defined will produce a ReferenceError . console.log(x); // ReferenceError: x is not defined let x = 'hi'; Best Practice : Leave var declarations inside of legacy code to denote that it needs to be carefully refactored. When working on a new codebase, use let for variables that will change their value over time, and const for variables which cannot be reassigned. (back to table of contents) Replacing IIFEs with Blocks A common use of Immediately Invoked Function Expressions is to enclose values within its scope. In ES6, we now have the ability to create block-based scopes and therefore are not limited purely to function-based scope. (function() { var food = 'Meow Mix'; })(); console.log(food); // Reference Error Using ES6 Blocks: { let food = 'Meow Mix'; } console.log(food); // Reference Error (back to table of contents) Arrow Functions Often times we have nested functions in which we would like to preserve the context of this from its lexical scope. An example is shown below: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map(function(character) { return this.name + character; // Cannot read property 'name' of undefined }); }; One common solution to this problem is to store the context of this using a variable: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { var that = this; // Store the context of this return arr.map(function(character) { return that.name + character; }); }; We can also pass in the proper context of this : function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map(function(character) { return this.name + character; }, this); }; As well as bind the context: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map( function(character) { return this.name + character; }.bind(this), ); }; Using Arrow Functions , the lexical value of this isn't shadowed and we can re-write the above as shown: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map((character) => this.name + character); }; Best Practice : Use Arrow Functions whenever you need to preserve the lexical value of this . Arrow Functions are also more concise when used in function expressions which simply return a value: var squares = arr.map(function(x) { return x * x; }); // Function Expression const arr = [1, 2, 3, 4, 5]; const squares = arr.map((x) => x * x); // Arrow Function for terser implementation Best Practice : Use Arrow Functions in place of function expressions when possible. (back to table of contents) Strings With ES6, the standard library has grown immensely. Along with these changes are new methods which can be used on strings, such as .includes() and .repeat() . .includes( ) var string = 'food'; var substring = 'foo'; console.log(string.indexOf(substring) > -1); Instead of checking for a return value > -1 to denote string containment, we can simply use .includes() which will return a boolean: const string = 'food'; const substring = 'foo'; console.log(string.includes(substring)); // true .repeat( ) function repeat(string, count) { var strings = []; while (strings.length < count) { strings.push(string); } return strings.join(''); } In ES6, we now have access to a terser implementation: // String.repeat(numberOfRepetitions) 'meow'.repeat(3); // 'meowmeowmeow' Template Literals Using Template Literals , we can now construct strings that have special characters in them without needing to escape them explicitly. var text = 'This string contains \"double quotes\" which are escaped.'; let text = `This string contains \"double quotes\" which don't need to be escaped anymore.`; Template Literals also support interpolation, which makes the task of concatenating strings and values: var name = 'Tiger'; var age = 13; console.log('My cat is named ' + name + ' and is ' + age + ' years old.'); Much simpler: const name = 'Tiger'; const age = 13; console.log(`My cat is named ${name} and is ${age} years old.`); In ES5, we handled new lines as follows: var text = 'cat\\n' + 'dog\\n' + 'nickelodeon'; Or: var text = ['cat', 'dog', 'nickelodeon'].join('\\n'); Template Literals will preserve new lines for us without having to explicitly place them in: let text = `cat dog nickelodeon`; Template Literals can accept expressions, as well: let today = new Date(); let text = `The time and date is ${today.toLocaleString()}`; (back to table of contents) Destructuring Destructuring allows us to extract values from arrays and objects (even deeply nested) and store them in variables with a more convenient syntax. Destructuring Arrays var arr = [1, 2, 3, 4]; var a = arr[0]; var b = arr[1]; var c = arr[2]; var d = arr[3]; let [a, b, c, d] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // 2 Destructuring Objects var luke = { occupation: 'jedi', father: 'anakin' }; var occupation = luke.occupation; // 'jedi' var father = luke.father; // 'anakin' let luke = { occupation: 'jedi', father: 'anakin' }; let { occupation, father } = luke; console.log(occupation); // 'jedi' console.log(father); // 'anakin' (back to table of contents) Modules Prior to ES6, we used libraries such as Browserify to create modules on the client-side, and require in Node.js . With ES6, we can now directly use modules of all types (AMD and CommonJS). Exporting in CommonJS module.exports = 1; module.exports = { foo: 'bar' }; module.exports = ['foo', 'bar']; module.exports = function bar() {}; Exporting in ES6 With ES6, we have various flavors of exporting. We can perform Named Exports : export let name = 'David'; export let age = 25;\u200b\u200b As well as exporting a list of objects: function sumTwo(a, b) { return a + b; } function sumThree(a, b, c) { return a + b + c; } export { sumTwo, sumThree }; We can also export functions, objects and values (etc.) simply by using the export keyword: export function sumTwo(a, b) { return a + b; } export function sumThree(a, b, c) { return a + b + c; } And lastly, we can export default bindings : function sumTwo(a, b) { return a + b; } function sumThree(a, b, c) { return a + b + c; } let api = { sumTwo, sumThree, }; export default api; /* Which is the same as * export { api as default }; */ Best Practices : Always use the export default method at the end of the module. It makes it clear what is being exported, and saves time by having to figure out what name a value was exported as. More so, the common practice in CommonJS modules is to export a single value or object. By sticking to this paradigm, we make our code easily readable and allow ourselves to interpolate between CommonJS and ES6 modules. Importing in ES6 ES6 provides us with various flavors of importing. We can import an entire file: import 'underscore'; It is important to note that simply importing an entire file will execute all code at the top level of that file . Similar to Python, we have named imports: import { sumTwo, sumThree } from 'math/addition'; We can also rename the named imports: import { sumTwo as addTwoNumbers, sumThree as sumThreeNumbers } from 'math/addition'; In addition, we can import all the things (also called namespace import): import * as util from 'math/addition'; Lastly, we can import a list of values from a module: import * as additionUtil from 'math/addition'; const { sumTwo, sumThree } = additionUtil; Importing from the default binding like this: import api from 'math/addition'; // Same as: import { default as api } from 'math/addition'; While it is better to keep the exports simple, but we can sometimes mix default import and mixed import if needed. When we are exporting like this: // foos.js export { foo as default, foo1, foo2 }; We can import them like the following: import foo, { foo1, foo2 } from 'foos'; When importing a module exported using commonjs syntax (such as React) we can do: import React from 'react'; const { Component, PropTypes } = React; This can also be simplified further, using: import React, { Component, PropTypes } from 'react'; Note : Values that are exported are bindings , not references. Therefore, changing the binding of a variable in one module will affect the value within the exported module. Avoid changing the public interface of these exported values. (back to table of contents) Parameters In ES5, we had varying ways to handle functions which needed default values , indefinite arguments , and named parameters . With ES6, we can accomplish all of this and more using more concise syntax. Default Parameters function addTwoNumbers(x, y) { x = x || 0; y = y || 0; return x + y; } In ES6, we can simply supply default values for parameters in a function: function addTwoNumbers(x = 0, y = 0) { return x + y; } addTwoNumbers(2, 4); // 6 addTwoNumbers(2); // 2 addTwoNumbers(); // 0 Rest Parameters In ES5, we handled an indefinite number of arguments like so: function logArguments() { for (var i = 0; i < arguments.length; i++) { console.log(arguments[i]); } } Using the rest operator, we can pass in an indefinite amount of arguments: function logArguments(...args) { for (let arg of args) { console.log(arg); } } Named Parameters One of the patterns in ES5 to handle named parameters was to use the options object pattern, adopted from jQuery. function initializeCanvas(options) { var height = options.height || 600; var width = options.width || 400; var lineStroke = options.lineStroke || 'black'; } We can achieve the same functionality using destructuring as a formal parameter to a function: function initializeCanvas({ height = 600, width = 400, lineStroke = 'black' }) { // Use variables height, width, lineStroke here } If we want to make the entire value optional, we can do so by destructuring an empty object: function initializeCanvas({ height = 600, width = 400, lineStroke = 'black' } = {}) { // ... } Spread Operator In ES5, we could find the max of values in an array by using the apply method on Math.max like this: Math.max.apply(null, [-1, 100, 9001, -32]); // 9001 In ES6, we can now use the spread operator to pass an array of values to be used as parameters to a function: Math.max(...[-1, 100, 9001, -32]); // 9001 We can concat array literals easily with this intuitive syntax: let cities = ['San Francisco', 'Los Angeles']; let places = ['Miami', ...cities, 'Chicago']; // ['Miami', 'San Francisco', 'Los Angeles', 'Chicago'] (back to table of contents) Classes Prior to ES6, we implemented Classes by creating a constructor function and adding properties by extending the prototype: function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } Person.prototype.incrementAge = function() { return (this.age += 1); }; And created extended classes by the following: function Personal(name, age, gender, occupation, hobby) { Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby; } Personal.prototype = Object.create(Person.prototype); Personal.prototype.constructor = Personal; Personal.prototype.incrementAge = function() { Person.prototype.incrementAge.call(this); this.age += 20; console.log(this.age); }; ES6 provides much needed syntactic sugar for doing this under the hood. We can create Classes directly: class Person { constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } incrementAge() { this.age += 1; } } And extend them using the extends keyword: class Personal extends Person { constructor(name, age, gender, occupation, hobby) { super(name, age, gender); this.occupation = occupation; this.hobby = hobby; } incrementAge() { super.incrementAge(); this.age += 20; console.log(this.age); } } Best Practice : While the syntax for creating classes in ES6 obscures how implementation and prototypes work under the hood, it is a good feature for beginners and allows us to write cleaner code. (back to table of contents) Symbols Symbols have existed prior to ES6, but now we have a public interface to using them directly. Symbols are immutable and unique and can be used as keys in any hash. Symbol( ) Calling Symbol() or Symbol(description) will create a unique symbol that cannot be looked up globally. A Use case for Symbol() is to patch objects or namespaces from third parties with your own logic, but be confident that you won't collide with updates to that library. For example, if you wanted to add a method refreshComponent to the React.Component class, and be certain that you didn't trample a method they add in a later update: const refreshComponent = Symbol(); React.Component.prototype[refreshComponent] = () => { // do something }; Symbol.for(key) Symbol.for(key) will create a Symbol that is still immutable and unique, but can be looked up globally. Two identical calls to Symbol.for(key) will return the same Symbol instance. NOTE: This is not true for Symbol(description) : Symbol('foo') === Symbol('foo'); // false Symbol.for('foo') === Symbol('foo'); // false Symbol.for('foo') === Symbol.for('foo'); // true A common use case for Symbols, and in particular with Symbol.for(key) is for interoperability. This can be achieved by having your code look for a Symbol member on object arguments from third parties that contain some known interface. For example: function reader(obj) { const specialRead = Symbol.for('specialRead'); if (obj[specialRead]) { const reader = obj[specialRead](); // do something with reader } else { throw new TypeError('object cannot be read'); } } And then in another library: const specialRead = Symbol.for('specialRead'); class SomeReadableType { [specialRead]() { const reader = createSomeReaderFrom(this); return reader; } } A notable example of Symbol use for interoperability is Symbol.iterator which exists on all iterable types in ES6: Arrays, strings, generators, etc. When called as a method it returns an object with an Iterator interface. (back to table of contents) Maps Maps is a much needed data structure in JavaScript. Prior to ES6, we created hash maps through objects: var map = new Object(); map[key1] = 'value1'; map[key2] = 'value2'; However, this does not protect us from accidentally overriding functions with specific property names: > getOwnProperty({ hasOwnProperty: 'Hah, overwritten'}, 'Pwned'); > TypeError: Property 'hasOwnProperty' is not a function Actual Maps allow us to set , get and search for values (and much more). let map = new Map(); > map.set('name', 'david'); > map.get('name'); // david > map.has('name'); // true The most amazing part of Maps is that we are no longer limited to just using strings. We can now use any type as a key, and it will not be type-cast to a string. let map = new Map([ ['name', 'david'], [true, 'false'], [1, 'one'], [{}, 'object'], [function() {}, 'function'], ]); for (let key of map.keys()) { console.log(typeof key); // > string, boolean, number, object, function } Note : Using non-primitive values such as functions or objects won't work when testing equality using methods such as map.get() . As such, stick to primitive values such as Strings, Booleans and Numbers. We can also iterate over maps using .entries() : for (let [key, value] of map.entries()) { console.log(key, value); } (back to table of contents) WeakMaps In order to store private data versions < ES6, we had various ways of doing this. One such method was using naming conventions: class Person { constructor(age) { this._age = age; } _incrementAge() { this._age += 1; } } But naming conventions can cause confusion in a codebase and are not always going to be upheld. Instead, we can use WeakMaps to store our values: let _age = new WeakMap(); class Person { constructor(age) { _age.set(this, age); } incrementAge() { let age = _age.get(this) + 1; _age.set(this, age); if (age > 50) { console.log('Midlife crisis'); } } } The cool thing about using WeakMaps to store our private data is that their keys do not give away the property names, which can be seen by using Reflect.ownKeys() : > const person = new Person(50); > person.incrementAge(); // 'Midlife crisis' > Reflect.ownKeys(person); // [] A more practical example of using WeakMaps is to store data which is associated to a DOM element without having to pollute the DOM itself: let map = new WeakMap(); let el = document.getElementById('someElement'); // Store a weak reference to the element with a key map.set(el, 'reference'); // Access the value of the element let value = map.get(el); // 'reference' // Remove the reference el.parentNode.removeChild(el); el = null; // map is empty, since the element is destroyed As shown above, once the object is destroyed by the garbage collector, the WeakMap will automatically remove the key-value pair which was identified by that object. Note : To further illustrate the usefulness of this example, consider how jQuery stores a cache of objects corresponding to DOM elements which have references. Using WeakMaps, jQuery can automatically free up any memory that was associated with a particular DOM element once it has been removed from the document. In general, WeakMaps are very useful for any library that wraps DOM elements. (back to table of contents) Promises Promises allow us to turn our horizontal code (callback hell): func1(function(value1) { func2(value1, function(value2) { func3(value2, function(value3) { func4(value3, function(value4) { func5(value4, function(value5) { // Do something with value 5 }); }); }); }); }); Into vertical code: func1(value1) .then(func2) .then(func3) .then(func4) .then(func5, (value5) => { // Do something with value 5 }); Prior to ES6, we used bluebird or Q . Now we have Promises natively: new Promise((resolve, reject) => reject(new Error('Failed to fulfill Promise'))).catch((reason) => console.log(reason), ); Where we have two handlers, resolve (a function called when the Promise is fulfilled ) and reject (a function called when the Promise is rejected ). Benefits of Promises : Error Handling using a bunch of nested callbacks can get chaotic. Using Promises, we have a clear path to bubbling errors up and handling them appropriately. Moreover, the value of a Promise after it has been resolved/rejected is immutable - it will never change. Here is a practical example of using Promises: var request = require('request'); return new Promise((resolve, reject) => { request.get(url, (error, response, body) => { if (body) { resolve(JSON.parse(body)); } else { resolve({}); } }); }); We can also parallelize Promises to handle an array of asynchronous operations by using Promise.all() : let urls = [ '/api/commits', '/api/issues/opened', '/api/issues/assigned', '/api/issues/completed', '/api/issues/comments', '/api/pullrequests', ]; let promises = urls.map((url) => { return new Promise((resolve, reject) => { $.ajax({ url: url }).done((data) => { resolve(data); }); }); }); Promise.all(promises).then((results) => { // Do something with results of all our promises }); (back to table of contents) Generators Similar to how Promises allow us to avoid callback hell , Generators allow us to flatten our code - giving our asynchronous code a synchronous feel. Generators are essentially functions which we can pause their execution and subsequently return the value of an expression. A simple example of using generators is shown below: function* sillyGenerator() { yield 1; yield 2; yield 3; yield 4; } var generator = sillyGenerator(); > console.log(generator.next()); // { value: 1, done: false } > console.log(generator.next()); // { value: 2, done: false } > console.log(generator.next()); // { value: 3, done: false } > console.log(generator.next()); // { value: 4, done: false } Where next will allow us to push our generator forward and evaluate a new expression. While the above example is extremely contrived, we can utilize Generators to write asynchronous code in a synchronous manner: // Hiding asynchronousity with Generators function request(url) { getJSON(url, function(response) { generator.next(response); }); } And here we write a generator function that will return our data: function* getData() { var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2); } By the power of yield , we are guaranteed that entry1 will have the data needed to be parsed and stored in data1 . While generators allow us to write asynchronous code in a synchronous manner, there is no clear and easy path for error propagation. As such, as we can augment our generator with Promises: function request(url) { return new Promise((resolve, reject) => { getJSON(url, resolve); }); } And we write a function which will step through our generator using next which in turn will utilize our request method above to yield a Promise: function iterateGenerator(gen) { var generator = gen(); (function iterate(val) { var ret = generator.next(); if (!ret.done) { ret.value.then(iterate); } })(); } By augmenting our Generator with Promises, we have a clear way of propagating errors through the use of our Promise .catch and reject . To use our newly augmented Generator, it is as simple as before: iterateGenerator(function* getData() { var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2); }); We were able to reuse our implementation to use our Generator as before, which shows their power. While Generators and Promises allow us to write asynchronous code in a synchronous manner while retaining the ability to propagate errors in a nice way, we can actually begin to utilize a simpler construction that provides the same benefits: async-await . (back to table of contents) Async Await While this is actually an upcoming ES2016 feature, async await allows us to perform the same thing we accomplished using Generators and Promises with less effort: var request = require('request'); function getJSON(url) { return new Promise(function(resolve, reject) { request(url, function(error, response, body) { resolve(body); }); }); } async function main() { var data = await getJSON(); console.log(data); // NOT undefined! } main(); Under the hood, it performs similarly to Generators. I highly recommend using them over Generators + Promises. A great resource for getting up and running with ES7 and Babel can be found here . (back to table of contents) Getter and setter functions ES6 has started supporting getter and setter functions within classes. Using the following example: class Employee { constructor(name) { this._name = name; } get name() { if (this._name) { return 'Mr. ' + this._name.toUpperCase(); } else { return undefined; } } set name(newName) { if (newName == this._name) { console.log('I already have this name.'); } else if (newName) { this._name = newName; } else { return false; } } } var emp = new Employee('James Bond'); // uses the get method in the background if (emp.name) { console.log(emp.name); // Mr. JAMES BOND } // uses the setter in the background emp.name = 'Bond 007'; console.log(emp.name); // Mr. BOND 007 Latest browsers are also supporting getter/setter functions in Objects and we can use them for computed properties, adding listeners and preprocessing before setting/getting: var person = { firstName: 'James', lastName: 'Bond', get fullName() { console.log('Getting FullName'); return this.firstName + ' ' + this.lastName; }, set fullName(name) { console.log('Setting FullName'); var words = name.toString().split(' '); this.firstName = words[0] || ''; this.lastName = words[1] || ''; }, }; person.fullName; // James Bond person.fullName = 'Bond 007'; person.fullName; // Bond 007 (back to table of contents)","title":"Index"},{"location":"js/#javascript-es6-best-practices","text":"Javascript ES6 best practices var versus let / const Replacing IIFEs with Blocks Arrow Functions Strings .includes( ) .repeat( ) Template Literals Destructuring Destructuring Arrays Destructuring Objects Modules Exporting in CommonJS Exporting in ES6 Importing in ES6 Parameters Default Parameters Rest Parameters Named Parameters Spread Operator Classes Symbols Symbol( ) Symbol.for(key) Maps WeakMaps Promises Generators Async Await Getter and setter functions","title":"Javascript ES6 best practices"},{"location":"js/#var-versus-let-const","text":"Besides var , we now have access to two new identifiers for storing values \u2014 let and const . Unlike var , let and const statements are not hoisted to the top of their enclosing scope. An example of using var : var snack = 'Meow Mix'; function getFood(food) { if (food) { var snack = 'Friskies'; return snack; } return snack; } getFood(false); // undefined However, observe what happens when we replace var using let : let snack = 'Meow Mix'; function getFood(food) { if (food) { let snack = 'Friskies'; return snack; } return snack; } getFood(false); // 'Meow Mix' This change in behavior highlights that we need to be careful when refactoring legacy code which uses var . Blindly replacing instances of var with let may lead to unexpected behavior. Note : let and const are block scoped. Therefore, referencing block-scoped identifiers before they are defined will produce a ReferenceError . console.log(x); // ReferenceError: x is not defined let x = 'hi'; Best Practice : Leave var declarations inside of legacy code to denote that it needs to be carefully refactored. When working on a new codebase, use let for variables that will change their value over time, and const for variables which cannot be reassigned. (back to table of contents)","title":"var versus let / const"},{"location":"js/#replacing-iifes-with-blocks","text":"A common use of Immediately Invoked Function Expressions is to enclose values within its scope. In ES6, we now have the ability to create block-based scopes and therefore are not limited purely to function-based scope. (function() { var food = 'Meow Mix'; })(); console.log(food); // Reference Error Using ES6 Blocks: { let food = 'Meow Mix'; } console.log(food); // Reference Error (back to table of contents)","title":"Replacing IIFEs with Blocks"},{"location":"js/#arrow-functions","text":"Often times we have nested functions in which we would like to preserve the context of this from its lexical scope. An example is shown below: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map(function(character) { return this.name + character; // Cannot read property 'name' of undefined }); }; One common solution to this problem is to store the context of this using a variable: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { var that = this; // Store the context of this return arr.map(function(character) { return that.name + character; }); }; We can also pass in the proper context of this : function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map(function(character) { return this.name + character; }, this); }; As well as bind the context: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map( function(character) { return this.name + character; }.bind(this), ); }; Using Arrow Functions , the lexical value of this isn't shadowed and we can re-write the above as shown: function Person(name) { this.name = name; } Person.prototype.prefixName = function(arr) { return arr.map((character) => this.name + character); }; Best Practice : Use Arrow Functions whenever you need to preserve the lexical value of this . Arrow Functions are also more concise when used in function expressions which simply return a value: var squares = arr.map(function(x) { return x * x; }); // Function Expression const arr = [1, 2, 3, 4, 5]; const squares = arr.map((x) => x * x); // Arrow Function for terser implementation Best Practice : Use Arrow Functions in place of function expressions when possible. (back to table of contents)","title":"Arrow Functions"},{"location":"js/#strings","text":"With ES6, the standard library has grown immensely. Along with these changes are new methods which can be used on strings, such as .includes() and .repeat() .","title":"Strings"},{"location":"js/#includes","text":"var string = 'food'; var substring = 'foo'; console.log(string.indexOf(substring) > -1); Instead of checking for a return value > -1 to denote string containment, we can simply use .includes() which will return a boolean: const string = 'food'; const substring = 'foo'; console.log(string.includes(substring)); // true","title":".includes( )"},{"location":"js/#repeat","text":"function repeat(string, count) { var strings = []; while (strings.length < count) { strings.push(string); } return strings.join(''); } In ES6, we now have access to a terser implementation: // String.repeat(numberOfRepetitions) 'meow'.repeat(3); // 'meowmeowmeow'","title":".repeat( )"},{"location":"js/#template-literals","text":"Using Template Literals , we can now construct strings that have special characters in them without needing to escape them explicitly. var text = 'This string contains \"double quotes\" which are escaped.'; let text = `This string contains \"double quotes\" which don't need to be escaped anymore.`; Template Literals also support interpolation, which makes the task of concatenating strings and values: var name = 'Tiger'; var age = 13; console.log('My cat is named ' + name + ' and is ' + age + ' years old.'); Much simpler: const name = 'Tiger'; const age = 13; console.log(`My cat is named ${name} and is ${age} years old.`); In ES5, we handled new lines as follows: var text = 'cat\\n' + 'dog\\n' + 'nickelodeon'; Or: var text = ['cat', 'dog', 'nickelodeon'].join('\\n'); Template Literals will preserve new lines for us without having to explicitly place them in: let text = `cat dog nickelodeon`; Template Literals can accept expressions, as well: let today = new Date(); let text = `The time and date is ${today.toLocaleString()}`; (back to table of contents)","title":"Template Literals"},{"location":"js/#destructuring","text":"Destructuring allows us to extract values from arrays and objects (even deeply nested) and store them in variables with a more convenient syntax.","title":"Destructuring"},{"location":"js/#destructuring-arrays","text":"var arr = [1, 2, 3, 4]; var a = arr[0]; var b = arr[1]; var c = arr[2]; var d = arr[3]; let [a, b, c, d] = [1, 2, 3, 4]; console.log(a); // 1 console.log(b); // 2","title":"Destructuring Arrays"},{"location":"js/#destructuring-objects","text":"var luke = { occupation: 'jedi', father: 'anakin' }; var occupation = luke.occupation; // 'jedi' var father = luke.father; // 'anakin' let luke = { occupation: 'jedi', father: 'anakin' }; let { occupation, father } = luke; console.log(occupation); // 'jedi' console.log(father); // 'anakin' (back to table of contents)","title":"Destructuring Objects"},{"location":"js/#modules","text":"Prior to ES6, we used libraries such as Browserify to create modules on the client-side, and require in Node.js . With ES6, we can now directly use modules of all types (AMD and CommonJS).","title":"Modules"},{"location":"js/#exporting-in-commonjs","text":"module.exports = 1; module.exports = { foo: 'bar' }; module.exports = ['foo', 'bar']; module.exports = function bar() {};","title":"Exporting in CommonJS"},{"location":"js/#exporting-in-es6","text":"With ES6, we have various flavors of exporting. We can perform Named Exports : export let name = 'David'; export let age = 25;\u200b\u200b As well as exporting a list of objects: function sumTwo(a, b) { return a + b; } function sumThree(a, b, c) { return a + b + c; } export { sumTwo, sumThree }; We can also export functions, objects and values (etc.) simply by using the export keyword: export function sumTwo(a, b) { return a + b; } export function sumThree(a, b, c) { return a + b + c; } And lastly, we can export default bindings : function sumTwo(a, b) { return a + b; } function sumThree(a, b, c) { return a + b + c; } let api = { sumTwo, sumThree, }; export default api; /* Which is the same as * export { api as default }; */ Best Practices : Always use the export default method at the end of the module. It makes it clear what is being exported, and saves time by having to figure out what name a value was exported as. More so, the common practice in CommonJS modules is to export a single value or object. By sticking to this paradigm, we make our code easily readable and allow ourselves to interpolate between CommonJS and ES6 modules.","title":"Exporting in ES6"},{"location":"js/#importing-in-es6","text":"ES6 provides us with various flavors of importing. We can import an entire file: import 'underscore'; It is important to note that simply importing an entire file will execute all code at the top level of that file . Similar to Python, we have named imports: import { sumTwo, sumThree } from 'math/addition'; We can also rename the named imports: import { sumTwo as addTwoNumbers, sumThree as sumThreeNumbers } from 'math/addition'; In addition, we can import all the things (also called namespace import): import * as util from 'math/addition'; Lastly, we can import a list of values from a module: import * as additionUtil from 'math/addition'; const { sumTwo, sumThree } = additionUtil; Importing from the default binding like this: import api from 'math/addition'; // Same as: import { default as api } from 'math/addition'; While it is better to keep the exports simple, but we can sometimes mix default import and mixed import if needed. When we are exporting like this: // foos.js export { foo as default, foo1, foo2 }; We can import them like the following: import foo, { foo1, foo2 } from 'foos'; When importing a module exported using commonjs syntax (such as React) we can do: import React from 'react'; const { Component, PropTypes } = React; This can also be simplified further, using: import React, { Component, PropTypes } from 'react'; Note : Values that are exported are bindings , not references. Therefore, changing the binding of a variable in one module will affect the value within the exported module. Avoid changing the public interface of these exported values. (back to table of contents)","title":"Importing in ES6"},{"location":"js/#parameters","text":"In ES5, we had varying ways to handle functions which needed default values , indefinite arguments , and named parameters . With ES6, we can accomplish all of this and more using more concise syntax.","title":"Parameters"},{"location":"js/#default-parameters","text":"function addTwoNumbers(x, y) { x = x || 0; y = y || 0; return x + y; } In ES6, we can simply supply default values for parameters in a function: function addTwoNumbers(x = 0, y = 0) { return x + y; } addTwoNumbers(2, 4); // 6 addTwoNumbers(2); // 2 addTwoNumbers(); // 0","title":"Default Parameters"},{"location":"js/#rest-parameters","text":"In ES5, we handled an indefinite number of arguments like so: function logArguments() { for (var i = 0; i < arguments.length; i++) { console.log(arguments[i]); } } Using the rest operator, we can pass in an indefinite amount of arguments: function logArguments(...args) { for (let arg of args) { console.log(arg); } }","title":"Rest Parameters"},{"location":"js/#named-parameters","text":"One of the patterns in ES5 to handle named parameters was to use the options object pattern, adopted from jQuery. function initializeCanvas(options) { var height = options.height || 600; var width = options.width || 400; var lineStroke = options.lineStroke || 'black'; } We can achieve the same functionality using destructuring as a formal parameter to a function: function initializeCanvas({ height = 600, width = 400, lineStroke = 'black' }) { // Use variables height, width, lineStroke here } If we want to make the entire value optional, we can do so by destructuring an empty object: function initializeCanvas({ height = 600, width = 400, lineStroke = 'black' } = {}) { // ... }","title":"Named Parameters"},{"location":"js/#spread-operator","text":"In ES5, we could find the max of values in an array by using the apply method on Math.max like this: Math.max.apply(null, [-1, 100, 9001, -32]); // 9001 In ES6, we can now use the spread operator to pass an array of values to be used as parameters to a function: Math.max(...[-1, 100, 9001, -32]); // 9001 We can concat array literals easily with this intuitive syntax: let cities = ['San Francisco', 'Los Angeles']; let places = ['Miami', ...cities, 'Chicago']; // ['Miami', 'San Francisco', 'Los Angeles', 'Chicago'] (back to table of contents)","title":"Spread Operator"},{"location":"js/#classes","text":"Prior to ES6, we implemented Classes by creating a constructor function and adding properties by extending the prototype: function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } Person.prototype.incrementAge = function() { return (this.age += 1); }; And created extended classes by the following: function Personal(name, age, gender, occupation, hobby) { Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby; } Personal.prototype = Object.create(Person.prototype); Personal.prototype.constructor = Personal; Personal.prototype.incrementAge = function() { Person.prototype.incrementAge.call(this); this.age += 20; console.log(this.age); }; ES6 provides much needed syntactic sugar for doing this under the hood. We can create Classes directly: class Person { constructor(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } incrementAge() { this.age += 1; } } And extend them using the extends keyword: class Personal extends Person { constructor(name, age, gender, occupation, hobby) { super(name, age, gender); this.occupation = occupation; this.hobby = hobby; } incrementAge() { super.incrementAge(); this.age += 20; console.log(this.age); } } Best Practice : While the syntax for creating classes in ES6 obscures how implementation and prototypes work under the hood, it is a good feature for beginners and allows us to write cleaner code. (back to table of contents)","title":"Classes"},{"location":"js/#symbols","text":"Symbols have existed prior to ES6, but now we have a public interface to using them directly. Symbols are immutable and unique and can be used as keys in any hash.","title":"Symbols"},{"location":"js/#symbol","text":"Calling Symbol() or Symbol(description) will create a unique symbol that cannot be looked up globally. A Use case for Symbol() is to patch objects or namespaces from third parties with your own logic, but be confident that you won't collide with updates to that library. For example, if you wanted to add a method refreshComponent to the React.Component class, and be certain that you didn't trample a method they add in a later update: const refreshComponent = Symbol(); React.Component.prototype[refreshComponent] = () => { // do something };","title":"Symbol( )"},{"location":"js/#symbolforkey","text":"Symbol.for(key) will create a Symbol that is still immutable and unique, but can be looked up globally. Two identical calls to Symbol.for(key) will return the same Symbol instance. NOTE: This is not true for Symbol(description) : Symbol('foo') === Symbol('foo'); // false Symbol.for('foo') === Symbol('foo'); // false Symbol.for('foo') === Symbol.for('foo'); // true A common use case for Symbols, and in particular with Symbol.for(key) is for interoperability. This can be achieved by having your code look for a Symbol member on object arguments from third parties that contain some known interface. For example: function reader(obj) { const specialRead = Symbol.for('specialRead'); if (obj[specialRead]) { const reader = obj[specialRead](); // do something with reader } else { throw new TypeError('object cannot be read'); } } And then in another library: const specialRead = Symbol.for('specialRead'); class SomeReadableType { [specialRead]() { const reader = createSomeReaderFrom(this); return reader; } } A notable example of Symbol use for interoperability is Symbol.iterator which exists on all iterable types in ES6: Arrays, strings, generators, etc. When called as a method it returns an object with an Iterator interface. (back to table of contents)","title":"Symbol.for(key)"},{"location":"js/#maps","text":"Maps is a much needed data structure in JavaScript. Prior to ES6, we created hash maps through objects: var map = new Object(); map[key1] = 'value1'; map[key2] = 'value2'; However, this does not protect us from accidentally overriding functions with specific property names: > getOwnProperty({ hasOwnProperty: 'Hah, overwritten'}, 'Pwned'); > TypeError: Property 'hasOwnProperty' is not a function Actual Maps allow us to set , get and search for values (and much more). let map = new Map(); > map.set('name', 'david'); > map.get('name'); // david > map.has('name'); // true The most amazing part of Maps is that we are no longer limited to just using strings. We can now use any type as a key, and it will not be type-cast to a string. let map = new Map([ ['name', 'david'], [true, 'false'], [1, 'one'], [{}, 'object'], [function() {}, 'function'], ]); for (let key of map.keys()) { console.log(typeof key); // > string, boolean, number, object, function } Note : Using non-primitive values such as functions or objects won't work when testing equality using methods such as map.get() . As such, stick to primitive values such as Strings, Booleans and Numbers. We can also iterate over maps using .entries() : for (let [key, value] of map.entries()) { console.log(key, value); } (back to table of contents)","title":"Maps"},{"location":"js/#weakmaps","text":"In order to store private data versions < ES6, we had various ways of doing this. One such method was using naming conventions: class Person { constructor(age) { this._age = age; } _incrementAge() { this._age += 1; } } But naming conventions can cause confusion in a codebase and are not always going to be upheld. Instead, we can use WeakMaps to store our values: let _age = new WeakMap(); class Person { constructor(age) { _age.set(this, age); } incrementAge() { let age = _age.get(this) + 1; _age.set(this, age); if (age > 50) { console.log('Midlife crisis'); } } } The cool thing about using WeakMaps to store our private data is that their keys do not give away the property names, which can be seen by using Reflect.ownKeys() : > const person = new Person(50); > person.incrementAge(); // 'Midlife crisis' > Reflect.ownKeys(person); // [] A more practical example of using WeakMaps is to store data which is associated to a DOM element without having to pollute the DOM itself: let map = new WeakMap(); let el = document.getElementById('someElement'); // Store a weak reference to the element with a key map.set(el, 'reference'); // Access the value of the element let value = map.get(el); // 'reference' // Remove the reference el.parentNode.removeChild(el); el = null; // map is empty, since the element is destroyed As shown above, once the object is destroyed by the garbage collector, the WeakMap will automatically remove the key-value pair which was identified by that object. Note : To further illustrate the usefulness of this example, consider how jQuery stores a cache of objects corresponding to DOM elements which have references. Using WeakMaps, jQuery can automatically free up any memory that was associated with a particular DOM element once it has been removed from the document. In general, WeakMaps are very useful for any library that wraps DOM elements. (back to table of contents)","title":"WeakMaps"},{"location":"js/#promises","text":"Promises allow us to turn our horizontal code (callback hell): func1(function(value1) { func2(value1, function(value2) { func3(value2, function(value3) { func4(value3, function(value4) { func5(value4, function(value5) { // Do something with value 5 }); }); }); }); }); Into vertical code: func1(value1) .then(func2) .then(func3) .then(func4) .then(func5, (value5) => { // Do something with value 5 }); Prior to ES6, we used bluebird or Q . Now we have Promises natively: new Promise((resolve, reject) => reject(new Error('Failed to fulfill Promise'))).catch((reason) => console.log(reason), ); Where we have two handlers, resolve (a function called when the Promise is fulfilled ) and reject (a function called when the Promise is rejected ). Benefits of Promises : Error Handling using a bunch of nested callbacks can get chaotic. Using Promises, we have a clear path to bubbling errors up and handling them appropriately. Moreover, the value of a Promise after it has been resolved/rejected is immutable - it will never change. Here is a practical example of using Promises: var request = require('request'); return new Promise((resolve, reject) => { request.get(url, (error, response, body) => { if (body) { resolve(JSON.parse(body)); } else { resolve({}); } }); }); We can also parallelize Promises to handle an array of asynchronous operations by using Promise.all() : let urls = [ '/api/commits', '/api/issues/opened', '/api/issues/assigned', '/api/issues/completed', '/api/issues/comments', '/api/pullrequests', ]; let promises = urls.map((url) => { return new Promise((resolve, reject) => { $.ajax({ url: url }).done((data) => { resolve(data); }); }); }); Promise.all(promises).then((results) => { // Do something with results of all our promises }); (back to table of contents)","title":"Promises"},{"location":"js/#generators","text":"Similar to how Promises allow us to avoid callback hell , Generators allow us to flatten our code - giving our asynchronous code a synchronous feel. Generators are essentially functions which we can pause their execution and subsequently return the value of an expression. A simple example of using generators is shown below: function* sillyGenerator() { yield 1; yield 2; yield 3; yield 4; } var generator = sillyGenerator(); > console.log(generator.next()); // { value: 1, done: false } > console.log(generator.next()); // { value: 2, done: false } > console.log(generator.next()); // { value: 3, done: false } > console.log(generator.next()); // { value: 4, done: false } Where next will allow us to push our generator forward and evaluate a new expression. While the above example is extremely contrived, we can utilize Generators to write asynchronous code in a synchronous manner: // Hiding asynchronousity with Generators function request(url) { getJSON(url, function(response) { generator.next(response); }); } And here we write a generator function that will return our data: function* getData() { var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2); } By the power of yield , we are guaranteed that entry1 will have the data needed to be parsed and stored in data1 . While generators allow us to write asynchronous code in a synchronous manner, there is no clear and easy path for error propagation. As such, as we can augment our generator with Promises: function request(url) { return new Promise((resolve, reject) => { getJSON(url, resolve); }); } And we write a function which will step through our generator using next which in turn will utilize our request method above to yield a Promise: function iterateGenerator(gen) { var generator = gen(); (function iterate(val) { var ret = generator.next(); if (!ret.done) { ret.value.then(iterate); } })(); } By augmenting our Generator with Promises, we have a clear way of propagating errors through the use of our Promise .catch and reject . To use our newly augmented Generator, it is as simple as before: iterateGenerator(function* getData() { var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2); }); We were able to reuse our implementation to use our Generator as before, which shows their power. While Generators and Promises allow us to write asynchronous code in a synchronous manner while retaining the ability to propagate errors in a nice way, we can actually begin to utilize a simpler construction that provides the same benefits: async-await . (back to table of contents)","title":"Generators"},{"location":"js/#async-await","text":"While this is actually an upcoming ES2016 feature, async await allows us to perform the same thing we accomplished using Generators and Promises with less effort: var request = require('request'); function getJSON(url) { return new Promise(function(resolve, reject) { request(url, function(error, response, body) { resolve(body); }); }); } async function main() { var data = await getJSON(); console.log(data); // NOT undefined! } main(); Under the hood, it performs similarly to Generators. I highly recommend using them over Generators + Promises. A great resource for getting up and running with ES7 and Babel can be found here . (back to table of contents)","title":"Async Await"},{"location":"js/#getter-and-setter-functions","text":"ES6 has started supporting getter and setter functions within classes. Using the following example: class Employee { constructor(name) { this._name = name; } get name() { if (this._name) { return 'Mr. ' + this._name.toUpperCase(); } else { return undefined; } } set name(newName) { if (newName == this._name) { console.log('I already have this name.'); } else if (newName) { this._name = newName; } else { return false; } } } var emp = new Employee('James Bond'); // uses the get method in the background if (emp.name) { console.log(emp.name); // Mr. JAMES BOND } // uses the setter in the background emp.name = 'Bond 007'; console.log(emp.name); // Mr. BOND 007 Latest browsers are also supporting getter/setter functions in Objects and we can use them for computed properties, adding listeners and preprocessing before setting/getting: var person = { firstName: 'James', lastName: 'Bond', get fullName() { console.log('Getting FullName'); return this.firstName + ' ' + this.lastName; }, set fullName(name) { console.log('Setting FullName'); var words = name.toString().split(' '); this.firstName = words[0] || ''; this.lastName = words[1] || ''; }, }; person.fullName; // James Bond person.fullName = 'Bond 007'; person.fullName; // Bond 007 (back to table of contents)","title":"Getter and setter functions"},{"location":"patterns/01/","text":"Conditions in JSX To render JSX conditionally, instead of: const sampleComponent = () => { return isTrue ? <p>True!</p> : null; }; Use short-circuit evaluation const sampleComponent = () => { return isTrue && <p>True!</p>; };","title":"Conditions in JSX"},{"location":"patterns/01/#conditions-in-jsx","text":"To render JSX conditionally, instead of: const sampleComponent = () => { return isTrue ? <p>True!</p> : null; }; Use short-circuit evaluation const sampleComponent = () => { return isTrue && <p>True!</p>; };","title":"Conditions in JSX"},{"location":"patterns/02/","text":"Higher-Order Components (or HOCs) in React are functions that take a component and return a new component, enhancing the original in some way: const EnhancedComponent = hoc(OriginalComponent); HOCs are very useful for injecting functions, state, and additional data into components as props, as well as wrapping components with styling or more JSX. Using HOCs allow us to only extend the components that need to be extended, while at the same time keeping your codebase modular by separating specialised logic from component implementations. HOCs are commonly (but not compulsorily) prefixed with with or get. with HOCs are expected to inject functionality whereas get HOCs are expected to inject data into the original component. In most cases you will be applying HOCs to components at export, after your original component is defined: import { withFunctions } from 'my-module'; class OriginalComponent extends React.Component { ... } export default withFunctions(OriginalComponent); Applying a HOC to a component is very simple; we just need to import the required HOC function and wrap the original component with it. The implementation of a HOC is also just as you would expect from a function; the following being our base implementation, returning an enhanced class component: export function withFunctions(OriginalComponent) { return class extends React.Component { // make some enhancements ... render() { //return original component with additional props return <OriginalComponent {...this.props} /> } } } HOC Example Dependency Injection In React the need of dependency injection is easily visible. Let's consider the following application tree: // Title.jsx export default function Title(props) { return <h1>{props.title}</h1>; } // Header.jsx import Title from './Title.jsx'; export default function Header() { return ( <header> <Title /> </header> ); } // App.jsx import Header from './Header.jsx'; class App extends React.Component { constructor(props) { super(props); this.state = { title: 'React Dependency Injection' }; } render() { return <Header />; } } The string \"React Dependency Injection\" should somehow reach the Title component. The direct way of doing this is to pass it from App to Header and then Header to pass it to Title. However, this may work for these three components but what happens if there are multiple properties and deeper nesting. Lots of components will have to mention properties that they are not interested in. It is clear that most React components receive their dependencies via props but the question is how these dependencies reach that point. One way to achieve dependency injection is by using higher-order component to inject data. // inject.jsx var title = 'React Dependency Injection'; export default function inject(Component) { return class Injector extends React.Component { render() { return <Component {...this.state} {...this.props} title={title} />; } }; } // Title.jsx export default function Title(props) { return <h1>{props.title}</h1>; } // Header.jsx import inject from './inject.jsx'; import Title from './Title.jsx'; var EnhancedTitle = inject(Title); export default function Header() { return ( <header> <EnhancedTitle /> </header> ); } The title is hidden in a middle layer (higher-order component) where we pass it as a prop to the original Title component. That's all nice but it solves only half of the problem. Now we don't have to pass the title down the tree but how this data will reach the enhance.jsx helper.","title":"02"},{"location":"patterns/02/#dependency-injection","text":"In React the need of dependency injection is easily visible. Let's consider the following application tree: // Title.jsx export default function Title(props) { return <h1>{props.title}</h1>; } // Header.jsx import Title from './Title.jsx'; export default function Header() { return ( <header> <Title /> </header> ); } // App.jsx import Header from './Header.jsx'; class App extends React.Component { constructor(props) { super(props); this.state = { title: 'React Dependency Injection' }; } render() { return <Header />; } } The string \"React Dependency Injection\" should somehow reach the Title component. The direct way of doing this is to pass it from App to Header and then Header to pass it to Title. However, this may work for these three components but what happens if there are multiple properties and deeper nesting. Lots of components will have to mention properties that they are not interested in. It is clear that most React components receive their dependencies via props but the question is how these dependencies reach that point. One way to achieve dependency injection is by using higher-order component to inject data. // inject.jsx var title = 'React Dependency Injection'; export default function inject(Component) { return class Injector extends React.Component { render() { return <Component {...this.state} {...this.props} title={title} />; } }; } // Title.jsx export default function Title(props) { return <h1>{props.title}</h1>; } // Header.jsx import inject from './inject.jsx'; import Title from './Title.jsx'; var EnhancedTitle = inject(Title); export default function Header() { return ( <header> <EnhancedTitle /> </header> ); } The title is hidden in a middle layer (higher-order component) where we pass it as a prop to the original Title component. That's all nice but it solves only half of the problem. Now we don't have to pass the title down the tree but how this data will reach the enhance.jsx helper.","title":"Dependency Injection"},{"location":"patterns/03/","text":"Presentational and Container components Problem Data and logic together. class Clock extends React.Component { constructor(props) { super(props); this.state = {time: this.props.time}; this._update = this._updateTime.bind(this); } render() { var time = this._formatTime(this.state.time); return ( <h1>{ time.hours } : { time.minutes } : { time.seconds }</h1> ); } componentDidMount() { this._interval = setInterval(this._update, 1000); } componentWillUnmount() { clearInterval(this._interval); } _formatTime(time) { var [ hours, minutes, seconds ] = [ time.getHours(), time.getMinutes(), time.getSeconds() ].map(num => num < 10 ? '0' + num : num); return {hours, minutes, seconds}; } _updateTime() { this.setState({time: new Date(this.state.time.getTime() + 1000)}); } } ReactDOM.render(<Clock time={ new Date() }/>, ...); Solution Let's split the component into two parts - container and presentation. Container Component Containers know about data, it's shape and where it comes from. They know details about how the things work or the so called business logic. They receive information and format it so it is easy to use by the presentational component. Very often we use higher-order components to create containers. Their render method contains only the presentational component. // Clock/index.js import Clock from './Clock.jsx'; // <-- that's the presentational component export default class ClockContainer extends React.Component { constructor(props) { super(props); this.state = { time: props.time }; this._update = this._updateTime.bind(this); } render() { return <Clock {...this._extract(this.state.time)} />; } componentDidMount() { this._interval = setInterval(this._update, 1000); } componentWillUnmount() { clearInterval(this._interval); } _extract(time) { return { hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds(), }; } _updateTime() { this.setState({ time: new Date(this.state.time.getTime() + 1000) }); } } Presentational component Presentational components are concerned with how the things look. They have the additional markup needed for making the page pretty. Such components are not bound to anything and have no dependencies. Very often implemented as a stateless functional components they don't have internal state. // Clock/Clock.jsx export default function Clock(props) { var [hours, minutes, seconds] = [props.hours, props.minutes, props.seconds].map((num) => num < 10 ? '0' + num : num, ); return ( <h1> {hours} : {minutes} : {seconds} </h1> ); } The nice things about containers is that they encapsulate logic and may inject data into different renderers. Very often a file that exports a container is not sending out a class directly but a function. For example, instead of using import Clock from './Clock.jsx'; export default class ClockContainer extends React.Component { render() { return <Clock />; } } We may export a function that accepts the presentational component: export default function(Component) { return class Container extends React.Component { render() { return <Component />; } }; } Using this technique our container is really flexible in rendering its result. It will be really helpful if we want to switch from digital to analog clock representation.","title":"Presentational and Container components"},{"location":"patterns/03/#presentational-and-container-components","text":"","title":"Presentational and Container components"},{"location":"patterns/03/#problem","text":"Data and logic together. class Clock extends React.Component { constructor(props) { super(props); this.state = {time: this.props.time}; this._update = this._updateTime.bind(this); } render() { var time = this._formatTime(this.state.time); return ( <h1>{ time.hours } : { time.minutes } : { time.seconds }</h1> ); } componentDidMount() { this._interval = setInterval(this._update, 1000); } componentWillUnmount() { clearInterval(this._interval); } _formatTime(time) { var [ hours, minutes, seconds ] = [ time.getHours(), time.getMinutes(), time.getSeconds() ].map(num => num < 10 ? '0' + num : num); return {hours, minutes, seconds}; } _updateTime() { this.setState({time: new Date(this.state.time.getTime() + 1000)}); } } ReactDOM.render(<Clock time={ new Date() }/>, ...);","title":"Problem"},{"location":"patterns/03/#solution","text":"Let's split the component into two parts - container and presentation.","title":"Solution"},{"location":"patterns/03/#container-component","text":"Containers know about data, it's shape and where it comes from. They know details about how the things work or the so called business logic. They receive information and format it so it is easy to use by the presentational component. Very often we use higher-order components to create containers. Their render method contains only the presentational component. // Clock/index.js import Clock from './Clock.jsx'; // <-- that's the presentational component export default class ClockContainer extends React.Component { constructor(props) { super(props); this.state = { time: props.time }; this._update = this._updateTime.bind(this); } render() { return <Clock {...this._extract(this.state.time)} />; } componentDidMount() { this._interval = setInterval(this._update, 1000); } componentWillUnmount() { clearInterval(this._interval); } _extract(time) { return { hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds(), }; } _updateTime() { this.setState({ time: new Date(this.state.time.getTime() + 1000) }); } }","title":"Container Component"},{"location":"patterns/03/#presentational-component","text":"Presentational components are concerned with how the things look. They have the additional markup needed for making the page pretty. Such components are not bound to anything and have no dependencies. Very often implemented as a stateless functional components they don't have internal state. // Clock/Clock.jsx export default function Clock(props) { var [hours, minutes, seconds] = [props.hours, props.minutes, props.seconds].map((num) => num < 10 ? '0' + num : num, ); return ( <h1> {hours} : {minutes} : {seconds} </h1> ); } The nice things about containers is that they encapsulate logic and may inject data into different renderers. Very often a file that exports a container is not sending out a class directly but a function. For example, instead of using import Clock from './Clock.jsx'; export default class ClockContainer extends React.Component { render() { return <Clock />; } } We may export a function that accepts the presentational component: export default function(Component) { return class Container extends React.Component { render() { return <Component />; } }; } Using this technique our container is really flexible in rendering its result. It will be really helpful if we want to switch from digital to analog clock representation.","title":"Presentational component"},{"location":"patterns/04/","text":"Decorators Decorators ( supported by Babel ) If you\u2019re using something like mobx, you can decorate your class components \u2014\u200awhich is the same as passing the component into a function. Decorators are flexible and readable way of modifying component functionality. Non-decorators approach class ProfileContainer extends Component { // Component code } export default observer(ProfileContainer); With decorators @observer export default class ProfileContainer extends Component { // Component code }","title":"Decorators"},{"location":"patterns/04/#decorators","text":"Decorators ( supported by Babel ) If you\u2019re using something like mobx, you can decorate your class components \u2014\u200awhich is the same as passing the component into a function. Decorators are flexible and readable way of modifying component functionality. Non-decorators approach class ProfileContainer extends Component { // Component code } export default observer(ProfileContainer); With decorators @observer export default class ProfileContainer extends Component { // Component code }","title":"Decorators"},{"location":"patterns/05/","text":"Event Handlers Binding event handlers in the constructor. Most of the times we handle DOM events in the component that contains the elements dispatching the events. Like in the example below, we have a click handler and we want to run a function or method of the same component: class Switcher extends React.Component { render() { return <button onClick={this._handleButtonClick}>click me</button>; } _handleButtonClick() { console.log('Button is clicked'); } } That's all fine because _handleButtonClick is a function and we indeed pass a function to the onClick attribute. The problem is that as it is the code doesn't keep the scope. So, if we have to use this inside _handleButtonClick we'll get an error. class Switcher extends React.Component { constructor(props) { super(props); this.state = { name: 'React in patterns' }; } render() { return <button onClick={this._handleButtonClick}>click me</button>; } _handleButtonClick() { console.log(`Button is clicked inside ${this.state.name}`); // leads to // Uncaught TypeError: Cannot read property 'state' of null } } What we normally do is to use bind like so: <button onClick={this._handleButtonClick.bind(this)}>click me</button> However, this means that the bind function is called again and again because we may render the button many times. A better approach would be to create the bindings in the constructor of the component: class Switcher extends React.Component { constructor(props) { super(props); this.state = { name: 'React in patterns' }; this._buttonClick = this._handleButtonClick.bind(this); } render() { return <button onClick={this._buttonClick}>click me</button>; } _handleButtonClick() { console.log(`Button is clicked inside ${this.state.name}`); } } The other alternative is to use arrow functions for the onClick prop function assignment. Arrow functions don't affect the context at invocation time ( this value from the surrounding scope is used). Facebook recommend the same technique while dealing with functions that need the context of the same component. The binding in the constructor may be also useful if we pass callbacks down the tree. A short hand example using arrow functions and avoid having to use the constructor: class Switcher extends React.Component { state = { name: 'React in patterns' }; render() { return <button onClick={this._handleButtonClick}>click me</button>; } _handleButtonClick = () => { console.log(`Button is clicked inside ${this.state.name}`); }; }","title":"Event Handlers"},{"location":"patterns/05/#event-handlers","text":"Binding event handlers in the constructor. Most of the times we handle DOM events in the component that contains the elements dispatching the events. Like in the example below, we have a click handler and we want to run a function or method of the same component: class Switcher extends React.Component { render() { return <button onClick={this._handleButtonClick}>click me</button>; } _handleButtonClick() { console.log('Button is clicked'); } } That's all fine because _handleButtonClick is a function and we indeed pass a function to the onClick attribute. The problem is that as it is the code doesn't keep the scope. So, if we have to use this inside _handleButtonClick we'll get an error. class Switcher extends React.Component { constructor(props) { super(props); this.state = { name: 'React in patterns' }; } render() { return <button onClick={this._handleButtonClick}>click me</button>; } _handleButtonClick() { console.log(`Button is clicked inside ${this.state.name}`); // leads to // Uncaught TypeError: Cannot read property 'state' of null } } What we normally do is to use bind like so: <button onClick={this._handleButtonClick.bind(this)}>click me</button> However, this means that the bind function is called again and again because we may render the button many times. A better approach would be to create the bindings in the constructor of the component: class Switcher extends React.Component { constructor(props) { super(props); this.state = { name: 'React in patterns' }; this._buttonClick = this._handleButtonClick.bind(this); } render() { return <button onClick={this._buttonClick}>click me</button>; } _handleButtonClick() { console.log(`Button is clicked inside ${this.state.name}`); } } The other alternative is to use arrow functions for the onClick prop function assignment. Arrow functions don't affect the context at invocation time ( this value from the surrounding scope is used). Facebook recommend the same technique while dealing with functions that need the context of the same component. The binding in the constructor may be also useful if we pass callbacks down the tree. A short hand example using arrow functions and avoid having to use the constructor: class Switcher extends React.Component { state = { name: 'React in patterns' }; render() { return <button onClick={this._handleButtonClick}>click me</button>; } _handleButtonClick = () => { console.log(`Button is clicked inside ${this.state.name}`); }; }","title":"Event Handlers"},{"location":"patterns/06/","text":"Passing a function to setState A little secret you might not know about setState\u200a\u2014\u200ait\u2019s actually asynchronous. React batches state changes for performance reasons, so the state may not change immediately after setState is called. That means you should not rely on the current state when calling setState\u200a\u2014\u200asince you can\u2019t be sure what that state will be! Here\u2019s the solution\u200a\u2014\u200apass a function to setState, with the previous state as an argument. Doing so avoids issues with the user getting the old state value on access (due to the asynchrony of setState) Problem // assuming this.state.count === 0 this.setState({ count: this.state.count + 1 }); this.setState({ count: this.state.count + 1 }); this.setState({ count: this.state.count + 1 }); // this.state.count === 1, not 3 Solution this.setState((prevState, props) => ({ count: prevState.count + props.increment, })); Variations // Passing object this.setState({ expanded: !this.state.expanded }); // Passing function this.setState((prevState) => ({ expanded: !prevState.expanded }));","title":"Passing a function to setState"},{"location":"patterns/06/#passing-a-function-to-setstate","text":"A little secret you might not know about setState\u200a\u2014\u200ait\u2019s actually asynchronous. React batches state changes for performance reasons, so the state may not change immediately after setState is called. That means you should not rely on the current state when calling setState\u200a\u2014\u200asince you can\u2019t be sure what that state will be! Here\u2019s the solution\u200a\u2014\u200apass a function to setState, with the previous state as an argument. Doing so avoids issues with the user getting the old state value on access (due to the asynchrony of setState)","title":"Passing a function to setState"},{"location":"patterns/06/#problem","text":"// assuming this.state.count === 0 this.setState({ count: this.state.count + 1 }); this.setState({ count: this.state.count + 1 }); this.setState({ count: this.state.count + 1 }); // this.state.count === 1, not 3","title":"Problem"},{"location":"patterns/06/#solution","text":"this.setState((prevState, props) => ({ count: prevState.count + props.increment, }));","title":"Solution"},{"location":"patterns/06/#variations","text":"// Passing object this.setState({ expanded: !this.state.expanded }); // Passing function this.setState((prevState) => ({ expanded: !prevState.expanded }));","title":"Variations"},{"location":"patterns/07/","text":"Composition Vs. Inheritance Inheritance For those familiar with Object Oriented Programming are well aware of Inheritance and use it on a regular basis. When a child class derives properties from it\u2019s parent class, we call it inheritance. There are variety of use-cases where inheritance can be useful. Example: A car is a vehicle can be modeled with inheritance. Let\u2019s look at a simple example of inheritance in JavaScript showing a Car is a Vehicle. class Vehicle { constructor (name, type) { this.name = name; this.type = type; } getName () { return this.name; } getType () { return this.type; } } class Car extends Vehicle { constructor (name) { super(name, 'car'); } getName () { return 'The car's name is: ' + super.getName(); } } Composition Composition is also a familiar concept in Object Oriented Programming. Instead of inheriting properties from a base class, it describes a class that can reference one or more objects of another class as instances. Example: A car has an engine can be modeled with composition. Now that we have recapped the differences between Inheritance and Composition, let\u2019s dive into what\u2019s the right fit for React. React prefers Composition over Inheritance Both Inheritance and Composition, aim towards code reuse and cleaner code structure. But what does the React team recommend? React recommends use of Composition over Inheritance, here is why. Everything in React is a component, and it follows a strong component based model. This is one of the primary reasons that composition is a better approach than inheritance for code reuse. Take a look at the simple code snippet below to understand how composition works in React. export default class Heading extends React.Component { render() { return ( <div> <h1>{this.props.message}</h1> </div> ); } } Heading.propTypes = { message: PropTypes.string, }; Heading.defaultProps = { message: 'Heading One', }; The component Heading is used to display a text message. Notice that for the Heading component the message needs to be passed in as a prop. If we fail to pass a prop, it uses the default props. The idea is that we can reuse the Heading component all across our code, and pass it a different heading message, depending on the screen that invokes it. The code snippet below shows how Heading can be used. // Container Component Screen One export default class ScreenOne extends React.Component { render() { return ( <div> <Heading message={'Custom Heading for Screen One'} /> </div> ); } } Notice here that ScreenOne is a container component. It uses the Heading component to display it\u2019s heading. It passes a custom message as a prop to the Heading component as shown above. Let\u2019s add another container component to our code and call it ScreenTwo. // Container Component Screen Two export default class ScreenTwo extends React.Component { render() { return ( <div> <Heading message={'Custom Heading for Screen Two'} /> </div> ); } } Notice here that ScreenTwo uses the same Heading component, but it passes a different message as prop to the component.","title":"Composition Vs. Inheritance"},{"location":"patterns/07/#composition-vs-inheritance","text":"Inheritance For those familiar with Object Oriented Programming are well aware of Inheritance and use it on a regular basis. When a child class derives properties from it\u2019s parent class, we call it inheritance. There are variety of use-cases where inheritance can be useful. Example: A car is a vehicle can be modeled with inheritance. Let\u2019s look at a simple example of inheritance in JavaScript showing a Car is a Vehicle. class Vehicle { constructor (name, type) { this.name = name; this.type = type; } getName () { return this.name; } getType () { return this.type; } } class Car extends Vehicle { constructor (name) { super(name, 'car'); } getName () { return 'The car's name is: ' + super.getName(); } } Composition Composition is also a familiar concept in Object Oriented Programming. Instead of inheriting properties from a base class, it describes a class that can reference one or more objects of another class as instances. Example: A car has an engine can be modeled with composition. Now that we have recapped the differences between Inheritance and Composition, let\u2019s dive into what\u2019s the right fit for React.","title":"Composition Vs. Inheritance"},{"location":"patterns/07/#react-prefers-composition-over-inheritance","text":"Both Inheritance and Composition, aim towards code reuse and cleaner code structure. But what does the React team recommend? React recommends use of Composition over Inheritance, here is why. Everything in React is a component, and it follows a strong component based model. This is one of the primary reasons that composition is a better approach than inheritance for code reuse. Take a look at the simple code snippet below to understand how composition works in React. export default class Heading extends React.Component { render() { return ( <div> <h1>{this.props.message}</h1> </div> ); } } Heading.propTypes = { message: PropTypes.string, }; Heading.defaultProps = { message: 'Heading One', }; The component Heading is used to display a text message. Notice that for the Heading component the message needs to be passed in as a prop. If we fail to pass a prop, it uses the default props. The idea is that we can reuse the Heading component all across our code, and pass it a different heading message, depending on the screen that invokes it. The code snippet below shows how Heading can be used. // Container Component Screen One export default class ScreenOne extends React.Component { render() { return ( <div> <Heading message={'Custom Heading for Screen One'} /> </div> ); } } Notice here that ScreenOne is a container component. It uses the Heading component to display it\u2019s heading. It passes a custom message as a prop to the Heading component as shown above. Let\u2019s add another container component to our code and call it ScreenTwo. // Container Component Screen Two export default class ScreenTwo extends React.Component { render() { return ( <div> <Heading message={'Custom Heading for Screen Two'} /> </div> ); } } Notice here that ScreenTwo uses the same Heading component, but it passes a different message as prop to the component.","title":"React prefers Composition over Inheritance"},{"location":"patterns/08/","text":"Lists Components If your component renders a list of nodes, instead of making a separate component for the list items, we can generate them like: const SearchSuggestions = (props) => { const SearchSuggestion = (listItem) => ( <li key={listItem.id}> {listItem.name} {listItem.id} </li> ); return <ul>{props.listItems.map(SearchSuggestion)}</ul>; }; If things get more complex or you want to use this component elsewhere, you should be able to copy/paste the code out into a new component. Don\u2019t prematurely componentize.","title":"Lists Components"},{"location":"patterns/08/#lists-components","text":"If your component renders a list of nodes, instead of making a separate component for the list items, we can generate them like: const SearchSuggestions = (props) => { const SearchSuggestion = (listItem) => ( <li key={listItem.id}> {listItem.name} {listItem.id} </li> ); return <ul>{props.listItems.map(SearchSuggestion)}</ul>; }; If things get more complex or you want to use this component elsewhere, you should be able to copy/paste the code out into a new component. Don\u2019t prematurely componentize.","title":"Lists Components"},{"location":"patterns/09/","text":"Conditions in JSX To render JSX conditionally, instead of: const sampleComponent = () => { return isTrue ? <p>True!</p> : null; }; Use short-circuit evaluation const sampleComponent = () => { return isTrue && <p>True!</p>; };","title":"Conditions in JSX"},{"location":"patterns/09/#conditions-in-jsx","text":"To render JSX conditionally, instead of: const sampleComponent = () => { return isTrue ? <p>True!</p> : null; }; Use short-circuit evaluation const sampleComponent = () => { return isTrue && <p>True!</p>; };","title":"Conditions in JSX"},{"location":"patterns/10/","text":"Conditions in JSX To render JSX conditionally, instead of: const sampleComponent = () => { return isTrue ? <p>True!</p> : null; }; Use short-circuit evaluation const sampleComponent = () => { return isTrue && <p>True!</p>; };","title":"Conditions in JSX"},{"location":"patterns/10/#conditions-in-jsx","text":"To render JSX conditionally, instead of: const sampleComponent = () => { return isTrue ? <p>True!</p> : null; }; Use short-circuit evaluation const sampleComponent = () => { return isTrue && <p>True!</p>; };","title":"Conditions in JSX"},{"location":"performance/01/","text":"Props in Initial State From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created. Bad class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } } Good class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Props in Initial State"},{"location":"performance/01/#props-in-initial-state","text":"From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created.","title":"Props in Initial State"},{"location":"performance/01/#bad","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } }","title":"Bad"},{"location":"performance/01/#good","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Good"},{"location":"performance/02/","text":"Props in Initial State From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created. Bad class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } } Good class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Props in Initial State"},{"location":"performance/02/#props-in-initial-state","text":"From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created.","title":"Props in Initial State"},{"location":"performance/02/#bad","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } }","title":"Bad"},{"location":"performance/02/#good","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Good"},{"location":"performance/03/","text":"Props in Initial State From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created. Bad class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } } Good class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Props in Initial State"},{"location":"performance/03/#props-in-initial-state","text":"From docs: Using props to generate state in getInitialState often leads to duplication of \u201csource of truth\u201d, i.e. where the real data is. This is because getInitialState is only invoked when the component is first created. The danger is that if the props on the component are changed without the component being \u2018refreshed\u2019, the new prop value will never be displayed because the constructor function (or getInitialState) will never update the current state of the component. The initialization of state from props only runs when the component is first created.","title":"Props in Initial State"},{"location":"performance/03/#bad","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, inputVal: props.inputValue, }; } render() { return <div>{this.state.inputVal && <AnotherComponent />}</div>; } }","title":"Bad"},{"location":"performance/03/#good","text":"class SampleComponent extends Component { // constructor function (or getInitialState) constructor(props) { super(props); this.state = { flag: false, }; } render() { return <div>{this.props.inputValue && <AnotherComponent />}</div>; } }","title":"Good"},{"location":"roadmap/","text":"React Developer Roadmap Below you can find a chart demonstrating the paths that you can take and the libraries that you would want to learn to become a React developer. Disclaimer The purpose of this roadmap is to give you an idea about the landscape. The road map will guide you if you are confused about what to learn next, rather than encouraging you to pick what is hip and trendy. You should grow some understanding of why one tool would be better suited for some cases than the other and remember hip and trendy does not always mean best suited for the job Roadmap Resources Basics HTML Learn the basics of HTML Make a few pages as an exercise CSS Learn the basics of CSS Style pages from previous step Build a page with grid and flexbox JS Basics Get familiar with the syntax Learn basic operations on DOM Learn mechanisms typical for JS (Hoisting, Event Bubbling, Prototyping) Make some AJAX (XHR) calls Learn new features (ECMA Script 6+) Additionally, get familiar with the jQuery library General Development Skills Learn GIT, create a few repositories on GitHub, share your code with other people Know HTTP(S) protocol, request methods (GET, POST, PUT, PATCH, DELETE, OPTIONS) Don't be afraid of using Google, Power Searching with Google Get familiar with terminal, configure your shell (bash, zsh, fish) Read a few books about algorithms and data structures Read a few books about design patterns Learn React on official website or complete some courses Get familiar with tools that you will be using Package Managers npm yarn pnpm Task Runners npm scripts gulp Webpack Rollup Parcel Styling CSS Preprocessor Sass/CSS PostCSS Less Stylus CSS Frameworks Bootstrap Materialize , Material UI , Material Design Lite Bulma Semantic UI CSS Architecture BEM CSS Modules Atomic OOCSS SMACSS SUITCSS CSS in JS Styled Components Radium Emotion JSS Aphrodite State Management Component State / Context API Redux Async actions (Side Effects) Redux Thunk Redux Better Promise Redux Saga Redux Observable Helpers Rematch Reselect Data persistence Redux Persist Redux Phoenix Redux Form MobX Type Checkers PropTypes TypeScript Flow Form Helpers Redux Form Formik Formsy Final Form Routing React-Router Router5 Redux-First Router Reach Router API Clients REST Fetch SuperAgent axios GraphQL Apollo Relay urql Utility Libraries Lodash Moment classnames Numeral RxJS ImmutableJS Ramda Testing Unit Testing Jest Enzyme Sinon Mocha Chai AVA Tape End to End Testing Selenium , Webdriver Cypress Puppeteer Cucumber.js Nightwatch.js Integration Testing Karma Internationalization React Intl React i18next Server Side Rendering Next.js After.js Rogue Static Site Generator Gatsby Backend Framework Integration React on Rails Mobile React Native Cordova / Phonegap Desktop Proton Native Electron React Native Windows Virtual Reality React 360 The original guide can be found here: https://github.com/adam-golab/react-developer-roadmap.","title":"React Developer Roadmap"},{"location":"roadmap/#react-developer-roadmap","text":"Below you can find a chart demonstrating the paths that you can take and the libraries that you would want to learn to become a React developer.","title":"React Developer Roadmap"},{"location":"roadmap/#disclaimer","text":"The purpose of this roadmap is to give you an idea about the landscape. The road map will guide you if you are confused about what to learn next, rather than encouraging you to pick what is hip and trendy. You should grow some understanding of why one tool would be better suited for some cases than the other and remember hip and trendy does not always mean best suited for the job","title":"Disclaimer"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#resources","text":"Basics HTML Learn the basics of HTML Make a few pages as an exercise CSS Learn the basics of CSS Style pages from previous step Build a page with grid and flexbox JS Basics Get familiar with the syntax Learn basic operations on DOM Learn mechanisms typical for JS (Hoisting, Event Bubbling, Prototyping) Make some AJAX (XHR) calls Learn new features (ECMA Script 6+) Additionally, get familiar with the jQuery library General Development Skills Learn GIT, create a few repositories on GitHub, share your code with other people Know HTTP(S) protocol, request methods (GET, POST, PUT, PATCH, DELETE, OPTIONS) Don't be afraid of using Google, Power Searching with Google Get familiar with terminal, configure your shell (bash, zsh, fish) Read a few books about algorithms and data structures Read a few books about design patterns Learn React on official website or complete some courses Get familiar with tools that you will be using Package Managers npm yarn pnpm Task Runners npm scripts gulp Webpack Rollup Parcel Styling CSS Preprocessor Sass/CSS PostCSS Less Stylus CSS Frameworks Bootstrap Materialize , Material UI , Material Design Lite Bulma Semantic UI CSS Architecture BEM CSS Modules Atomic OOCSS SMACSS SUITCSS CSS in JS Styled Components Radium Emotion JSS Aphrodite State Management Component State / Context API Redux Async actions (Side Effects) Redux Thunk Redux Better Promise Redux Saga Redux Observable Helpers Rematch Reselect Data persistence Redux Persist Redux Phoenix Redux Form MobX Type Checkers PropTypes TypeScript Flow Form Helpers Redux Form Formik Formsy Final Form Routing React-Router Router5 Redux-First Router Reach Router API Clients REST Fetch SuperAgent axios GraphQL Apollo Relay urql Utility Libraries Lodash Moment classnames Numeral RxJS ImmutableJS Ramda Testing Unit Testing Jest Enzyme Sinon Mocha Chai AVA Tape End to End Testing Selenium , Webdriver Cypress Puppeteer Cucumber.js Nightwatch.js Integration Testing Karma Internationalization React Intl React i18next Server Side Rendering Next.js After.js Rogue Static Site Generator Gatsby Backend Framework Integration React on Rails Mobile React Native Cordova / Phonegap Desktop Proton Native Electron React Native Windows Virtual Reality React 360 The original guide can be found here: https://github.com/adam-golab/react-developer-roadmap.","title":"Resources"},{"location":"tests/01/","text":"Why automate testing? There are many reasons why automated tests are useful but my favorite reason is: you\u2019re already testing. For example, you\u2019re adding a new button to a page. Then you open this page in a browser and click this button to check whether it works\u202f\u2014\u202fthis is a manual test. By automating this process you can be sure that features that used to work will always work as they should. Automated tests are especially useful for rarely used features: we always test whether the button submits the form with all fields filled correctly, but we tend to forget to test that checkbox hidden in a modal and only used by the boss of your boss. Automated tests will make sure it still works. Other reasons to automate tests are: Confidence to change code: well-written tests allow you to refactor code with confidence that you\u2019re not breaking anything, and without wasting time updating the tests. Documentation: tests explain how code works and what\u2019s the expected behavior. Tests, in comparison to any written documentation, are always up to date. Bugs and regression prevention: by adding test cases for every bug, found in your app, you can be sure that these bugs will never come back. Writing tests will improve your understanding of the code and the requirements, you\u2019ll critically look at your code and find issues that you\u2019d miss otherwise. Automated tests make it possible to catch bugs before you commit them to the repository, in comparison to manual testing where you find most of the bugs during testing or even in production. What to test? The testing trophy, introduced by Kent C. Dodds is popular for the frontend tests: It says that integration tests give you the biggest return on investment, so you should write more integration tests than any other kinds of tests. End-to-end tests in the trophy mostly correspond to UI tests in the pyramid. Integration tests verify big features or even whole pages but without any backend, a real database or a real browser. For example, render a login page, type a username and a password, click the \u201cLog in\u201d button and verify that the correct network request was sent, but without actually making any network requests\u202f\u2014\u202fwe\u2019ll learn how to do it later. Even if integration tests are more expensive to write, they have several benefits over unit tests: Unit tests Integration tests One test covers only one module One test covers a whole feature or a page Often require rewrite after refactoring Survive refactoring most of the time Hard to avoid testing implementation details Better resemble how users are using your app The last point is important: integration tests give us the most confidence that our app works as expected. But it doesn\u2019t mean, that we should only write integration tests. Other tests have their place but we should focus our efforts on tests, that are the most useful. Now, let\u2019s look closely at each testing trophy level, from the very bottom: 1- Static analysis catches syntax errors, bad practices and incorrect use of APIs: \u202f\u2014\u202fCode formatters, like Prettier; \u202f\u2014\u202fLinters, like ESLint; \u202f\u2014\u202fType checkers, like TypeScript and Flow. 2- Unit tests verify that tricky algorithms work correctly. Tools: Jest. 3- Integration tests give you confidence that all features of your app work as expected. Tools: Jest and Enzyme or react-testing-library. 4- End-to-end tests make sure that your app work as a whole: the frontend and the backend and the database and everything else. Tools: Cypress. Unit testing best practices Let's look at some best practices for building, running, and maintaining unit tests, to achieve the best results. Unit Tests Should Be Trustworthy The test must fail if the code is broken and only if the code is broken. If it doesn't, we cannot trust what the test results are telling us. Unit Tests Should Be Maintainable and Readable When production code changes, tests often need to be updated, and possibly debugged as well. So it must be easy to read and understand the test, not only for whoever wrote it, but for other developers as well. Always organize and name your tests for clarity and readability. Unit Tests Should Verify a Single-Use Case Good tests validate one thing and one thing only, which means that typically, they validate a single use-case. Tests that follow this best practice are simpler and more understandable, and that is good for maintainability and debugging. Tests that validate more than one thing can easily become complex and time-consuming to maintain. Don't let this happen. Unit Tests Should Be Isolated Tests should be runnable on any machine, in any order, without affecting each other. If possible, tests should have no dependencies on environmental factors or global/external state. Tests that have these dependencies are harder to run and usually unstable, making them harder to debug and fix, and end up costing more time than they save. Unit Tests Should Be Automated Make sure tests are being run in an automated process. This can be daily, or every hour, or in a Continuous Integration or Delivery process. The reports need to be accessible to and reviewed by everyone on the team. As a team, talk about which metrics you care about: code coverage, modified code coverage, number of tests being run, performance, etc.","title":"Why automate testing?"},{"location":"tests/01/#why-automate-testing","text":"There are many reasons why automated tests are useful but my favorite reason is: you\u2019re already testing. For example, you\u2019re adding a new button to a page. Then you open this page in a browser and click this button to check whether it works\u202f\u2014\u202fthis is a manual test. By automating this process you can be sure that features that used to work will always work as they should. Automated tests are especially useful for rarely used features: we always test whether the button submits the form with all fields filled correctly, but we tend to forget to test that checkbox hidden in a modal and only used by the boss of your boss. Automated tests will make sure it still works. Other reasons to automate tests are: Confidence to change code: well-written tests allow you to refactor code with confidence that you\u2019re not breaking anything, and without wasting time updating the tests. Documentation: tests explain how code works and what\u2019s the expected behavior. Tests, in comparison to any written documentation, are always up to date. Bugs and regression prevention: by adding test cases for every bug, found in your app, you can be sure that these bugs will never come back. Writing tests will improve your understanding of the code and the requirements, you\u2019ll critically look at your code and find issues that you\u2019d miss otherwise. Automated tests make it possible to catch bugs before you commit them to the repository, in comparison to manual testing where you find most of the bugs during testing or even in production.","title":"Why automate testing?"},{"location":"tests/01/#what-to-test","text":"The testing trophy, introduced by Kent C. Dodds is popular for the frontend tests: It says that integration tests give you the biggest return on investment, so you should write more integration tests than any other kinds of tests. End-to-end tests in the trophy mostly correspond to UI tests in the pyramid. Integration tests verify big features or even whole pages but without any backend, a real database or a real browser. For example, render a login page, type a username and a password, click the \u201cLog in\u201d button and verify that the correct network request was sent, but without actually making any network requests\u202f\u2014\u202fwe\u2019ll learn how to do it later. Even if integration tests are more expensive to write, they have several benefits over unit tests: Unit tests Integration tests One test covers only one module One test covers a whole feature or a page Often require rewrite after refactoring Survive refactoring most of the time Hard to avoid testing implementation details Better resemble how users are using your app The last point is important: integration tests give us the most confidence that our app works as expected. But it doesn\u2019t mean, that we should only write integration tests. Other tests have their place but we should focus our efforts on tests, that are the most useful. Now, let\u2019s look closely at each testing trophy level, from the very bottom: 1- Static analysis catches syntax errors, bad practices and incorrect use of APIs: \u202f\u2014\u202fCode formatters, like Prettier; \u202f\u2014\u202fLinters, like ESLint; \u202f\u2014\u202fType checkers, like TypeScript and Flow. 2- Unit tests verify that tricky algorithms work correctly. Tools: Jest. 3- Integration tests give you confidence that all features of your app work as expected. Tools: Jest and Enzyme or react-testing-library. 4- End-to-end tests make sure that your app work as a whole: the frontend and the backend and the database and everything else. Tools: Cypress.","title":"What to test?"},{"location":"tests/01/#unit-testing-best-practices","text":"Let's look at some best practices for building, running, and maintaining unit tests, to achieve the best results. Unit Tests Should Be Trustworthy The test must fail if the code is broken and only if the code is broken. If it doesn't, we cannot trust what the test results are telling us. Unit Tests Should Be Maintainable and Readable When production code changes, tests often need to be updated, and possibly debugged as well. So it must be easy to read and understand the test, not only for whoever wrote it, but for other developers as well. Always organize and name your tests for clarity and readability. Unit Tests Should Verify a Single-Use Case Good tests validate one thing and one thing only, which means that typically, they validate a single use-case. Tests that follow this best practice are simpler and more understandable, and that is good for maintainability and debugging. Tests that validate more than one thing can easily become complex and time-consuming to maintain. Don't let this happen. Unit Tests Should Be Isolated Tests should be runnable on any machine, in any order, without affecting each other. If possible, tests should have no dependencies on environmental factors or global/external state. Tests that have these dependencies are harder to run and usually unstable, making them harder to debug and fix, and end up costing more time than they save. Unit Tests Should Be Automated Make sure tests are being run in an automated process. This can be daily, or every hour, or in a Continuous Integration or Delivery process. The reports need to be accessible to and reviewed by everyone on the team. As a team, talk about which metrics you care about: code coverage, modified code coverage, number of tests being run, performance, etc.","title":"Unit testing best practices"}]}