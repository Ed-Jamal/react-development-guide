<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.1.2, mkdocs-material-5.5.12"><title>Index - React Development Guide | Ed Jamal</title><link rel=stylesheet href=../assets/stylesheets/main.4dd2dd8d.min.css><link rel=stylesheet href=../assets/stylesheets/palette.6a5ad368.min.css><meta name=theme-color content=#4cae4f><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#javascript-es6-best-practices class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=.. title="React Development Guide" class="md-header-nav__button md-logo" aria-label="React Development Guide"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <span class="md-header-nav__topic md-ellipsis"> React Development Guide  | Ed Jamal</span> <span class="md-header-nav__topic md-ellipsis"> Index </span> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="React Development Guide" class="md-nav__button md-logo" aria-label="React Development Guide"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> React Development Guide | Ed Jamal </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. title=Home class=md-nav__link> Home </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#javascript-es6-best-practices class=md-nav__link> Javascript ES6 best practices </a> </li> <li class=md-nav__item> <a href=#var-versus-let-const class=md-nav__link> var versus let / const </a> </li> <li class=md-nav__item> <a href=#replacing-iifes-with-blocks class=md-nav__link> Replacing IIFEs with Blocks </a> </li> <li class=md-nav__item> <a href=#arrow-functions class=md-nav__link> Arrow Functions </a> </li> <li class=md-nav__item> <a href=#strings class=md-nav__link> Strings </a> <nav class=md-nav aria-label=Strings> <ul class=md-nav__list> <li class=md-nav__item> <a href=#includes class=md-nav__link> .includes( ) </a> </li> <li class=md-nav__item> <a href=#repeat class=md-nav__link> .repeat( ) </a> </li> <li class=md-nav__item> <a href=#template-literals class=md-nav__link> Template Literals </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#destructuring class=md-nav__link> Destructuring </a> <nav class=md-nav aria-label=Destructuring> <ul class=md-nav__list> <li class=md-nav__item> <a href=#destructuring-arrays class=md-nav__link> Destructuring Arrays </a> </li> <li class=md-nav__item> <a href=#destructuring-objects class=md-nav__link> Destructuring Objects </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#modules class=md-nav__link> Modules </a> <nav class=md-nav aria-label=Modules> <ul class=md-nav__list> <li class=md-nav__item> <a href=#exporting-in-commonjs class=md-nav__link> Exporting in CommonJS </a> </li> <li class=md-nav__item> <a href=#exporting-in-es6 class=md-nav__link> Exporting in ES6 </a> </li> <li class=md-nav__item> <a href=#importing-in-es6 class=md-nav__link> Importing in ES6 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#parameters class=md-nav__link> Parameters </a> <nav class=md-nav aria-label=Parameters> <ul class=md-nav__list> <li class=md-nav__item> <a href=#default-parameters class=md-nav__link> Default Parameters </a> </li> <li class=md-nav__item> <a href=#rest-parameters class=md-nav__link> Rest Parameters </a> </li> <li class=md-nav__item> <a href=#named-parameters class=md-nav__link> Named Parameters </a> </li> <li class=md-nav__item> <a href=#spread-operator class=md-nav__link> Spread Operator </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#classes class=md-nav__link> Classes </a> </li> <li class=md-nav__item> <a href=#symbols class=md-nav__link> Symbols </a> <nav class=md-nav aria-label=Symbols> <ul class=md-nav__list> <li class=md-nav__item> <a href=#symbol class=md-nav__link> Symbol( ) </a> </li> <li class=md-nav__item> <a href=#symbolforkey class=md-nav__link> Symbol.for(key) </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#maps class=md-nav__link> Maps </a> </li> <li class=md-nav__item> <a href=#weakmaps class=md-nav__link> WeakMaps </a> </li> <li class=md-nav__item> <a href=#promises class=md-nav__link> Promises </a> </li> <li class=md-nav__item> <a href=#generators class=md-nav__link> Generators </a> </li> <li class=md-nav__item> <a href=#async-await class=md-nav__link> Async Await </a> </li> <li class=md-nav__item> <a href=#getter-and-setter-functions class=md-nav__link> Getter and setter functions </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1>Index</h1> <h2 id=javascript-es6-best-practices>Javascript ES6 best practices</h2> <ul> <li><a href=#javascript-es6-best-practices>Javascript ES6 best practices</a></li> <li><a href=#var-versus-let--const>var versus let / const</a></li> <li><a href=#replacing-iifes-with-blocks>Replacing IIFEs with Blocks</a></li> <li><a href=#arrow-functions>Arrow Functions</a></li> <li><a href=#strings>Strings</a></li> <li><a href=#includes->.includes( )</a></li> <li><a href=#repeat->.repeat( )</a></li> <li><a href=#template-literals>Template Literals</a></li> <li><a href=#destructuring>Destructuring</a></li> <li><a href=#destructuring-arrays>Destructuring Arrays</a></li> <li><a href=#destructuring-objects>Destructuring Objects</a></li> <li><a href=#modules>Modules</a></li> <li><a href=#exporting-in-commonjs>Exporting in CommonJS</a></li> <li><a href=#exporting-in-es6>Exporting in ES6</a></li> <li><a href=#importing-in-es6>Importing in ES6</a></li> <li><a href=#parameters>Parameters</a></li> <li><a href=#default-parameters>Default Parameters</a></li> <li><a href=#rest-parameters>Rest Parameters</a></li> <li><a href=#named-parameters>Named Parameters</a></li> <li><a href=#spread-operator>Spread Operator</a></li> <li><a href=#classes>Classes</a></li> <li><a href=#symbols>Symbols</a></li> <li><a href=#symbol->Symbol( )</a></li> <li><a href=#symbolforkey>Symbol.for(key)</a></li> <li><a href=#maps>Maps</a></li> <li><a href=#weakmaps>WeakMaps</a></li> <li><a href=#promises>Promises</a></li> <li><a href=#generators>Generators</a></li> <li><a href=#async-await>Async Await</a></li> <li><a href=#getter-and-setter-functions>Getter and setter functions</a></li> </ul> <h2 id=var-versus-let-const>var versus let / const</h2> <blockquote> <p>Besides <code>var</code>, we now have access to two new identifiers for storing values —<code>let</code> and <code>const</code>. Unlike <code>var</code>, <code>let</code> and <code>const</code> statements are not hoisted to the top of their enclosing scope.</p> </blockquote> <p>An example of using <code>var</code>:</p> <pre><code class=javascript>var snack = 'Meow Mix';

function getFood(food) {
  if (food) {
    var snack = 'Friskies';
    return snack;
  }
  return snack;
}

getFood(false); // undefined
</code></pre> <p>However, observe what happens when we replace <code>var</code> using <code>let</code>:</p> <pre><code class=javascript>let snack = 'Meow Mix';

function getFood(food) {
  if (food) {
    let snack = 'Friskies';
    return snack;
  }
  return snack;
}

getFood(false); // 'Meow Mix'
</code></pre> <p>This change in behavior highlights that we need to be careful when refactoring legacy code which uses <code>var</code>. Blindly replacing instances of <code>var</code> with <code>let</code> may lead to unexpected behavior.</p> <blockquote> <p><strong>Note</strong>: <code>let</code> and <code>const</code> are block scoped. Therefore, referencing block-scoped identifiers before they are defined will produce a <code>ReferenceError</code>.</p> </blockquote> <pre><code class=javascript>console.log(x); // ReferenceError: x is not defined

let x = 'hi';
</code></pre> <blockquote> <p><strong>Best Practice</strong>: Leave <code>var</code> declarations inside of legacy code to denote that it needs to be carefully refactored. When working on a new codebase, use <code>let</code> for variables that will change their value over time, and <code>const</code> for variables which cannot be reassigned.</p> </blockquote> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=replacing-iifes-with-blocks>Replacing IIFEs with Blocks</h2> <blockquote> <p>A common use of <strong>Immediately Invoked Function Expressions</strong> is to enclose values within its scope. In ES6, we now have the ability to create block-based scopes and therefore are not limited purely to function-based scope.</p> </blockquote> <pre><code class=javascript>(function() {
  var food = 'Meow Mix';
})();

console.log(food); // Reference Error
</code></pre> <p>Using ES6 Blocks:</p> <pre><code class=javascript>{
  let food = 'Meow Mix';
}

console.log(food); // Reference Error
</code></pre> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=arrow-functions>Arrow Functions</h2> <p>Often times we have nested functions in which we would like to preserve the context of <code>this</code> from its lexical scope. An example is shown below:</p> <pre><code class=javascript>function Person(name) {
  this.name = name;
}

Person.prototype.prefixName = function(arr) {
  return arr.map(function(character) {
    return this.name + character; // Cannot read property 'name' of undefined
  });
};
</code></pre> <p>One common solution to this problem is to store the context of <code>this</code> using a variable:</p> <pre><code class=javascript>function Person(name) {
  this.name = name;
}

Person.prototype.prefixName = function(arr) {
  var that = this; // Store the context of this
  return arr.map(function(character) {
    return that.name + character;
  });
};
</code></pre> <p>We can also pass in the proper context of <code>this</code>:</p> <pre><code class=javascript>function Person(name) {
  this.name = name;
}

Person.prototype.prefixName = function(arr) {
  return arr.map(function(character) {
    return this.name + character;
  }, this);
};
</code></pre> <p>As well as bind the context:</p> <pre><code class=javascript>function Person(name) {
  this.name = name;
}

Person.prototype.prefixName = function(arr) {
  return arr.map(
    function(character) {
      return this.name + character;
    }.bind(this),
  );
};
</code></pre> <p>Using <strong>Arrow Functions</strong>, the lexical value of <code>this</code> isn't shadowed and we can re-write the above as shown:</p> <pre><code class=javascript>function Person(name) {
  this.name = name;
}

Person.prototype.prefixName = function(arr) {
  return arr.map((character) =&gt; this.name + character);
};
</code></pre> <blockquote> <p><strong>Best Practice</strong>: Use <strong>Arrow Functions</strong> whenever you need to preserve the lexical value of <code>this</code>.</p> </blockquote> <p>Arrow Functions are also more concise when used in function expressions which simply return a value:</p> <pre><code class=javascript>var squares = arr.map(function(x) {
  return x * x;
}); // Function Expression
</code></pre> <pre><code class=javascript>const arr = [1, 2, 3, 4, 5];
const squares = arr.map((x) =&gt; x * x); // Arrow Function for terser implementation
</code></pre> <blockquote> <p><strong>Best Practice</strong>: Use <strong>Arrow Functions</strong> in place of function expressions when possible.</p> </blockquote> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=strings>Strings</h2> <p>With ES6, the standard library has grown immensely. Along with these changes are new methods which can be used on strings, such as <code>.includes()</code> and <code>.repeat()</code>.</p> <h3 id=includes>.includes( )</h3> <pre><code class=javascript>var string = 'food';
var substring = 'foo';

console.log(string.indexOf(substring) &gt; -1);
</code></pre> <p>Instead of checking for a return value <code>&gt; -1</code> to denote string containment, we can simply use <code>.includes()</code> which will return a boolean:</p> <pre><code class=javascript>const string = 'food';
const substring = 'foo';

console.log(string.includes(substring)); // true
</code></pre> <h3 id=repeat>.repeat( )</h3> <pre><code class=javascript>function repeat(string, count) {
  var strings = [];
  while (strings.length &lt; count) {
    strings.push(string);
  }
  return strings.join('');
}
</code></pre> <p>In ES6, we now have access to a terser implementation:</p> <pre><code class=javascript>// String.repeat(numberOfRepetitions)
'meow'.repeat(3); // 'meowmeowmeow'
</code></pre> <h3 id=template-literals>Template Literals</h3> <p>Using <strong>Template Literals</strong>, we can now construct strings that have special characters in them without needing to escape them explicitly.</p> <pre><code class=javascript>var text = 'This string contains &quot;double quotes&quot; which are escaped.';
</code></pre> <pre><code class=javascript>let text = `This string contains &quot;double quotes&quot; which don't need to be escaped anymore.`;
</code></pre> <p><strong>Template Literals</strong> also support interpolation, which makes the task of concatenating strings and values:</p> <pre><code class=javascript>var name = 'Tiger';
var age = 13;

console.log('My cat is named ' + name + ' and is ' + age + ' years old.');
</code></pre> <p>Much simpler:</p> <pre><code class=javascript>const name = 'Tiger';
const age = 13;

console.log(`My cat is named ${name} and is ${age} years old.`);
</code></pre> <p>In ES5, we handled new lines as follows:</p> <pre><code class=javascript>var text = 'cat\n' + 'dog\n' + 'nickelodeon';
</code></pre> <p>Or:</p> <pre><code class=javascript>var text = ['cat', 'dog', 'nickelodeon'].join('\n');
</code></pre> <p><strong>Template Literals</strong> will preserve new lines for us without having to explicitly place them in:</p> <pre><code class=javascript>let text = `cat
dog
nickelodeon`;
</code></pre> <p><strong>Template Literals</strong> can accept expressions, as well:</p> <pre><code class=javascript>let today = new Date();
let text = `The time and date is ${today.toLocaleString()}`;
</code></pre> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=destructuring>Destructuring</h2> <p>Destructuring allows us to extract values from arrays and objects (even deeply nested) and store them in variables with a more convenient syntax.</p> <h3 id=destructuring-arrays>Destructuring Arrays</h3> <pre><code class=javascript>var arr = [1, 2, 3, 4];
var a = arr[0];
var b = arr[1];
var c = arr[2];
var d = arr[3];
</code></pre> <pre><code class=javascript>let [a, b, c, d] = [1, 2, 3, 4];

console.log(a); // 1
console.log(b); // 2
</code></pre> <h3 id=destructuring-objects>Destructuring Objects</h3> <pre><code class=javascript>var luke = { occupation: 'jedi', father: 'anakin' };
var occupation = luke.occupation; // 'jedi'
var father = luke.father; // 'anakin'
</code></pre> <pre><code class=javascript>let luke = { occupation: 'jedi', father: 'anakin' };
let { occupation, father } = luke;

console.log(occupation); // 'jedi'
console.log(father); // 'anakin'
</code></pre> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=modules>Modules</h2> <p>Prior to ES6, we used libraries such as <a href=http://browserify.org/ >Browserify</a> to create modules on the client-side, and <a href=https://nodejs.org/api/modules.html#modules_module_require_id>require</a> in <strong>Node.js</strong>. With ES6, we can now directly use modules of all types (AMD and CommonJS).</p> <h3 id=exporting-in-commonjs>Exporting in CommonJS</h3> <pre><code class=javascript>module.exports = 1;
module.exports = { foo: 'bar' };
module.exports = ['foo', 'bar'];
module.exports = function bar() {};
</code></pre> <h3 id=exporting-in-es6>Exporting in ES6</h3> <p>With ES6, we have various flavors of exporting. We can perform <strong>Named Exports</strong>:</p> <pre><code class=javascript>export let name = 'David';
export let age  = 25;​​
</code></pre> <p>As well as <strong>exporting a list</strong> of objects:</p> <pre><code class=javascript>function sumTwo(a, b) {
  return a + b;
}

function sumThree(a, b, c) {
  return a + b + c;
}

export { sumTwo, sumThree };
</code></pre> <p>We can also export functions, objects and values (etc.) simply by using the <code>export</code> keyword:</p> <pre><code class=javascript>export function sumTwo(a, b) {
  return a + b;
}

export function sumThree(a, b, c) {
  return a + b + c;
}
</code></pre> <p>And lastly, we can <strong>export default bindings</strong>:</p> <pre><code class=javascript>function sumTwo(a, b) {
  return a + b;
}

function sumThree(a, b, c) {
  return a + b + c;
}

let api = {
  sumTwo,
  sumThree,
};

export default api;

/* Which is the same as
 * export { api as default };
 */
</code></pre> <blockquote> <p><strong>Best Practices</strong>: Always use the <code>export default</code> method at <strong>the end</strong> of the module. It makes it clear what is being exported, and saves time by having to figure out what name a value was exported as. More so, the common practice in CommonJS modules is to export a single value or object. By sticking to this paradigm, we make our code easily readable and allow ourselves to interpolate between CommonJS and ES6 modules.</p> </blockquote> <h3 id=importing-in-es6>Importing in ES6</h3> <p>ES6 provides us with various flavors of importing. We can import an entire file:</p> <pre><code class=javascript>import 'underscore';
</code></pre> <blockquote> <p>It is important to note that simply <strong>importing an entire file will execute all code at the top level of that file</strong>.</p> </blockquote> <p>Similar to Python, we have named imports:</p> <pre><code class=javascript>import { sumTwo, sumThree } from 'math/addition';
</code></pre> <p>We can also rename the named imports:</p> <pre><code class=javascript>import { sumTwo as addTwoNumbers, sumThree as sumThreeNumbers } from 'math/addition';
</code></pre> <p>In addition, we can <strong>import all the things</strong> (also called namespace import):</p> <pre><code class=javascript>import * as util from 'math/addition';
</code></pre> <p>Lastly, we can import a list of values from a module:</p> <pre><code class=javascript>import * as additionUtil from 'math/addition';
const { sumTwo, sumThree } = additionUtil;
</code></pre> <p>Importing from the default binding like this:</p> <pre><code class=javascript>import api from 'math/addition';
// Same as: import { default as api } from 'math/addition';
</code></pre> <p>While it is better to keep the exports simple, but we can sometimes mix default import and mixed import if needed. When we are exporting like this:</p> <pre><code class=javascript>// foos.js
export { foo as default, foo1, foo2 };
</code></pre> <p>We can import them like the following:</p> <pre><code class=javascript>import foo, { foo1, foo2 } from 'foos';
</code></pre> <p>When importing a module exported using commonjs syntax (such as React) we can do:</p> <pre><code class=javascript>import React from 'react';
const { Component, PropTypes } = React;
</code></pre> <p>This can also be simplified further, using:</p> <pre><code class=javascript>import React, { Component, PropTypes } from 'react';
</code></pre> <blockquote> <p><strong>Note</strong>: Values that are exported are <strong>bindings</strong>, not references. Therefore, changing the binding of a variable in one module will affect the value within the exported module. Avoid changing the public interface of these exported values.</p> </blockquote> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=parameters>Parameters</h2> <p>In ES5, we had varying ways to handle functions which needed <strong>default values</strong>, <strong>indefinite arguments</strong>, and <strong>named parameters</strong>. With ES6, we can accomplish all of this and more using more concise syntax.</p> <h3 id=default-parameters>Default Parameters</h3> <pre><code class=javascript>function addTwoNumbers(x, y) {
  x = x || 0;
  y = y || 0;
  return x + y;
}
</code></pre> <p>In ES6, we can simply supply default values for parameters in a function:</p> <pre><code class=javascript>function addTwoNumbers(x = 0, y = 0) {
  return x + y;
}
</code></pre> <pre><code class=javascript>addTwoNumbers(2, 4); // 6
addTwoNumbers(2); // 2
addTwoNumbers(); // 0
</code></pre> <h3 id=rest-parameters>Rest Parameters</h3> <p>In ES5, we handled an indefinite number of arguments like so:</p> <pre><code class=javascript>function logArguments() {
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(arguments[i]);
  }
}
</code></pre> <p>Using the <strong>rest</strong> operator, we can pass in an indefinite amount of arguments:</p> <pre><code class=javascript>function logArguments(...args) {
  for (let arg of args) {
    console.log(arg);
  }
}
</code></pre> <h3 id=named-parameters>Named Parameters</h3> <p>One of the patterns in ES5 to handle named parameters was to use the <strong>options object</strong> pattern, adopted from jQuery.</p> <pre><code class=javascript>function initializeCanvas(options) {
  var height = options.height || 600;
  var width = options.width || 400;
  var lineStroke = options.lineStroke || 'black';
}
</code></pre> <p>We can achieve the same functionality using destructuring as a formal parameter to a function:</p> <pre><code class=javascript>function initializeCanvas({ height = 600, width = 400, lineStroke = 'black' }) {
  // Use variables height, width, lineStroke here
}
</code></pre> <p>If we want to make the entire value optional, we can do so by destructuring an empty object:</p> <pre><code class=javascript>function initializeCanvas({ height = 600, width = 400, lineStroke = 'black' } = {}) {
  // ...
}
</code></pre> <h3 id=spread-operator>Spread Operator</h3> <p>In ES5, we could find the max of values in an array by using the <code>apply</code> method on <code>Math.max</code> like this:</p> <pre><code class=javascript>Math.max.apply(null, [-1, 100, 9001, -32]); // 9001
</code></pre> <p>In ES6, we can now use the spread operator to pass an array of values to be used as parameters to a function:</p> <pre><code class=javascript>Math.max(...[-1, 100, 9001, -32]); // 9001
</code></pre> <p>We can concat array literals easily with this intuitive syntax:</p> <pre><code class=javascript>let cities = ['San Francisco', 'Los Angeles'];
let places = ['Miami', ...cities, 'Chicago']; // ['Miami', 'San Francisco', 'Los Angeles', 'Chicago']
</code></pre> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=classes>Classes</h2> <p>Prior to ES6, we implemented Classes by creating a constructor function and adding properties by extending the prototype:</p> <pre><code class=javascript>function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
}

Person.prototype.incrementAge = function() {
  return (this.age += 1);
};
</code></pre> <p>And created extended classes by the following:</p> <pre><code class=javascript>function Personal(name, age, gender, occupation, hobby) {
  Person.call(this, name, age, gender);
  this.occupation = occupation;
  this.hobby = hobby;
}

Personal.prototype = Object.create(Person.prototype);
Personal.prototype.constructor = Personal;
Personal.prototype.incrementAge = function() {
  Person.prototype.incrementAge.call(this);
  this.age += 20;
  console.log(this.age);
};
</code></pre> <p>ES6 provides much needed syntactic sugar for doing this under the hood. We can create Classes directly:</p> <pre><code class=javascript>class Person {
  constructor(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }

  incrementAge() {
    this.age += 1;
  }
}
</code></pre> <p>And extend them using the <code>extends</code> keyword:</p> <pre><code class=javascript>class Personal extends Person {
  constructor(name, age, gender, occupation, hobby) {
    super(name, age, gender);
    this.occupation = occupation;
    this.hobby = hobby;
  }

  incrementAge() {
    super.incrementAge();
    this.age += 20;
    console.log(this.age);
  }
}
</code></pre> <blockquote> <p><strong>Best Practice</strong>: While the syntax for creating classes in ES6 obscures how implementation and prototypes work under the hood, it is a good feature for beginners and allows us to write cleaner code.</p> </blockquote> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=symbols>Symbols</h2> <p>Symbols have existed prior to ES6, but now we have a public interface to using them directly. Symbols are immutable and unique and can be used as keys in any hash.</p> <h3 id=symbol>Symbol( )</h3> <p>Calling <code>Symbol()</code> or <code>Symbol(description)</code> will create a unique symbol that cannot be looked up globally. A Use case for <code>Symbol()</code> is to patch objects or namespaces from third parties with your own logic, but be confident that you won't collide with updates to that library. For example, if you wanted to add a method <code>refreshComponent</code> to the <code>React.Component</code> class, and be certain that you didn't trample a method they add in a later update:</p> <pre><code class=javascript>const refreshComponent = Symbol();

React.Component.prototype[refreshComponent] = () =&gt; {
  // do something
};
</code></pre> <h3 id=symbolforkey>Symbol.for(key)</h3> <p><code>Symbol.for(key)</code> will create a Symbol that is still immutable and unique, but can be looked up globally. Two identical calls to <code>Symbol.for(key)</code> will return the same Symbol instance. NOTE: This is not true for <code>Symbol(description)</code>:</p> <pre><code class=javascript>Symbol('foo') === Symbol('foo'); // false
Symbol.for('foo') === Symbol('foo'); // false
Symbol.for('foo') === Symbol.for('foo'); // true
</code></pre> <p>A common use case for Symbols, and in particular with <code>Symbol.for(key)</code> is for interoperability. This can be achieved by having your code look for a Symbol member on object arguments from third parties that contain some known interface. For example:</p> <pre><code class=javascript>function reader(obj) {
  const specialRead = Symbol.for('specialRead');
  if (obj[specialRead]) {
    const reader = obj[specialRead]();
    // do something with reader
  } else {
    throw new TypeError('object cannot be read');
  }
}
</code></pre> <p>And then in another library:</p> <pre><code class=javascript>const specialRead = Symbol.for('specialRead');

class SomeReadableType {
  [specialRead]() {
    const reader = createSomeReaderFrom(this);
    return reader;
  }
}
</code></pre> <blockquote> <p>A notable example of Symbol use for interoperability is <code>Symbol.iterator</code> which exists on all iterable types in ES6: Arrays, strings, generators, etc. When called as a method it returns an object with an Iterator interface.</p> </blockquote> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=maps>Maps</h2> <p><strong>Maps</strong> is a much needed data structure in JavaScript. Prior to ES6, we created <strong>hash</strong> maps through objects:</p> <pre><code class=javascript>var map = new Object();
map[key1] = 'value1';
map[key2] = 'value2';
</code></pre> <p>However, this does not protect us from accidentally overriding functions with specific property names:</p> <pre><code class=javascript>&gt; getOwnProperty({ hasOwnProperty: 'Hah, overwritten'}, 'Pwned');
&gt; TypeError: Property 'hasOwnProperty' is not a function
</code></pre> <p>Actual <strong>Maps</strong> allow us to <code>set</code>, <code>get</code> and <code>search</code> for values (and much more).</p> <pre><code class=javascript>let map = new Map();
&gt; map.set('name', 'david');
&gt; map.get('name'); // david
&gt; map.has('name'); // true
</code></pre> <p>The most amazing part of Maps is that we are no longer limited to just using strings. We can now use any type as a key, and it will not be type-cast to a string.</p> <pre><code class=javascript>let map = new Map([
  ['name', 'david'],
  [true, 'false'],
  [1, 'one'],
  [{}, 'object'],
  [function() {}, 'function'],
]);

for (let key of map.keys()) {
  console.log(typeof key);
  // &gt; string, boolean, number, object, function
}
</code></pre> <blockquote> <p><strong>Note</strong>: Using non-primitive values such as functions or objects won't work when testing equality using methods such as <code>map.get()</code>. As such, stick to primitive values such as Strings, Booleans and Numbers.</p> </blockquote> <p>We can also iterate over maps using <code>.entries()</code>:</p> <pre><code class=javascript>for (let [key, value] of map.entries()) {
  console.log(key, value);
}
</code></pre> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=weakmaps>WeakMaps</h2> <p>In order to store private data versions &lt; ES6, we had various ways of doing this. One such method was using naming conventions:</p> <pre><code class=javascript>class Person {
  constructor(age) {
    this._age = age;
  }

  _incrementAge() {
    this._age += 1;
  }
}
</code></pre> <p>But naming conventions can cause confusion in a codebase and are not always going to be upheld. Instead, we can use WeakMaps to store our values:</p> <pre><code class=javascript>let _age = new WeakMap();
class Person {
  constructor(age) {
    _age.set(this, age);
  }

  incrementAge() {
    let age = _age.get(this) + 1;
    _age.set(this, age);
    if (age &gt; 50) {
      console.log('Midlife crisis');
    }
  }
}
</code></pre> <p>The cool thing about using WeakMaps to store our private data is that their keys do not give away the property names, which can be seen by using <code>Reflect.ownKeys()</code>:</p> <pre><code class=javascript>&gt; const person = new Person(50);
&gt; person.incrementAge(); // 'Midlife crisis'
&gt; Reflect.ownKeys(person); // []
</code></pre> <p>A more practical example of using WeakMaps is to store data which is associated to a DOM element without having to pollute the DOM itself:</p> <pre><code class=javascript>let map = new WeakMap();
let el = document.getElementById('someElement');

// Store a weak reference to the element with a key
map.set(el, 'reference');

// Access the value of the element
let value = map.get(el); // 'reference'

// Remove the reference
el.parentNode.removeChild(el);
el = null;

// map is empty, since the element is destroyed
</code></pre> <p>As shown above, once the object is destroyed by the garbage collector, the WeakMap will automatically remove the key-value pair which was identified by that object.</p> <blockquote> <p><strong>Note</strong>: To further illustrate the usefulness of this example, consider how jQuery stores a cache of objects corresponding to DOM elements which have references. Using WeakMaps, jQuery can automatically free up any memory that was associated with a particular DOM element once it has been removed from the document. In general, WeakMaps are very useful for any library that wraps DOM elements.</p> </blockquote> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=promises>Promises</h2> <p>Promises allow us to turn our horizontal code (callback hell):</p> <pre><code class=javascript>func1(function(value1) {
  func2(value1, function(value2) {
    func3(value2, function(value3) {
      func4(value3, function(value4) {
        func5(value4, function(value5) {
          // Do something with value 5
        });
      });
    });
  });
});
</code></pre> <p>Into vertical code:</p> <pre><code class=javascript>func1(value1)
  .then(func2)
  .then(func3)
  .then(func4)
  .then(func5, (value5) =&gt; {
    // Do something with value 5
  });
</code></pre> <p>Prior to ES6, we used <a href=https://github.com/petkaantonov/bluebird>bluebird</a> or <a href=https://github.com/kriskowal/q>Q</a>. Now we have Promises natively:</p> <pre><code class=javascript>new Promise((resolve, reject) =&gt; reject(new Error('Failed to fulfill Promise'))).catch((reason) =&gt;
  console.log(reason),
);
</code></pre> <p>Where we have two handlers, <strong>resolve</strong> (a function called when the Promise is <strong>fulfilled</strong>) and <strong>reject</strong> (a function called when the Promise is <strong>rejected</strong>).</p> <blockquote> <p><strong>Benefits of Promises</strong>: Error Handling using a bunch of nested callbacks can get chaotic. Using Promises, we have a clear path to bubbling errors up and handling them appropriately. Moreover, the value of a Promise after it has been resolved/rejected is immutable - it will never change.</p> </blockquote> <p>Here is a practical example of using Promises:</p> <pre><code class=javascript>var request = require('request');

return new Promise((resolve, reject) =&gt; {
  request.get(url, (error, response, body) =&gt; {
    if (body) {
      resolve(JSON.parse(body));
    } else {
      resolve({});
    }
  });
});
</code></pre> <p>We can also <strong>parallelize</strong> Promises to handle an array of asynchronous operations by using <code>Promise.all()</code>:</p> <pre><code class=javascript>let urls = [
  '/api/commits',
  '/api/issues/opened',
  '/api/issues/assigned',
  '/api/issues/completed',
  '/api/issues/comments',
  '/api/pullrequests',
];

let promises = urls.map((url) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    $.ajax({ url: url }).done((data) =&gt; {
      resolve(data);
    });
  });
});

Promise.all(promises).then((results) =&gt; {
  // Do something with results of all our promises
});
</code></pre> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=generators>Generators</h2> <p>Similar to how <a href=https://github.com/DrkSephy/es6-cheatsheet#promises>Promises</a> allow us to avoid <a href=http://callbackhell.com/ >callback hell</a>, Generators allow us to flatten our code - giving our asynchronous code a synchronous feel. Generators are essentially functions which we can <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield>pause their execution</a> and subsequently return the value of an expression.</p> <p>A simple example of using generators is shown below:</p> <pre><code class=javascript>function* sillyGenerator() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}

var generator = sillyGenerator();
&gt; console.log(generator.next()); // { value: 1, done: false }
&gt; console.log(generator.next()); // { value: 2, done: false }
&gt; console.log(generator.next()); // { value: 3, done: false }
&gt; console.log(generator.next()); // { value: 4, done: false }
</code></pre> <p>Where <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next>next</a> will allow us to push our generator forward and evaluate a new expression. While the above example is extremely contrived, we can utilize Generators to write asynchronous code in a synchronous manner:</p> <pre><code class=javascript>// Hiding asynchronousity with Generators

function request(url) {
  getJSON(url, function(response) {
    generator.next(response);
  });
}
</code></pre> <p>And here we write a generator function that will return our data:</p> <pre><code class=javascript>function* getData() {
  var entry1 = yield request('http://some_api/item1');
  var data1 = JSON.parse(entry1);
  var entry2 = yield request('http://some_api/item2');
  var data2 = JSON.parse(entry2);
}
</code></pre> <p>By the power of <code>yield</code>, we are guaranteed that <code>entry1</code> will have the data needed to be parsed and stored in <code>data1</code>.</p> <p>While generators allow us to write asynchronous code in a synchronous manner, there is no clear and easy path for error propagation. As such, as we can augment our generator with Promises:</p> <pre><code class=javascript>function request(url) {
  return new Promise((resolve, reject) =&gt; {
    getJSON(url, resolve);
  });
}
</code></pre> <p>And we write a function which will step through our generator using <code>next</code> which in turn will utilize our <code>request</code> method above to yield a Promise:</p> <pre><code class=javascript>function iterateGenerator(gen) {
  var generator = gen();
  (function iterate(val) {
    var ret = generator.next();
    if (!ret.done) {
      ret.value.then(iterate);
    }
  })();
}
</code></pre> <p>By augmenting our Generator with Promises, we have a clear way of propagating errors through the use of our Promise <code>.catch</code> and <code>reject</code>. To use our newly augmented Generator, it is as simple as before:</p> <pre><code class=javascript>iterateGenerator(function* getData() {
  var entry1 = yield request('http://some_api/item1');
  var data1 = JSON.parse(entry1);
  var entry2 = yield request('http://some_api/item2');
  var data2 = JSON.parse(entry2);
});
</code></pre> <p>We were able to reuse our implementation to use our Generator as before, which shows their power. While Generators and Promises allow us to write asynchronous code in a synchronous manner while retaining the ability to propagate errors in a nice way, we can actually begin to utilize a simpler construction that provides the same benefits: <a href=https://github.com/DrkSephy/es6-cheatsheet#async-await>async-await</a>.</p> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=async-await>Async Await</h2> <p>While this is actually an upcoming ES2016 feature, <code>async await</code> allows us to perform the same thing we accomplished using Generators and Promises with less effort:</p> <pre><code class=javascript>var request = require('request');

function getJSON(url) {
  return new Promise(function(resolve, reject) {
    request(url, function(error, response, body) {
      resolve(body);
    });
  });
}

async function main() {
  var data = await getJSON();
  console.log(data); // NOT undefined!
}

main();
</code></pre> <p>Under the hood, it performs similarly to Generators. I highly recommend using them over Generators + Promises. A great resource for getting up and running with ES7 and Babel can be found <a href=http://masnun.com/2015/11/11/using-es7-asyncawait-today-with-babel.html>here</a>.</p> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> <h2 id=getter-and-setter-functions>Getter and setter functions</h2> <p>ES6 has started supporting getter and setter functions within classes. Using the following example:</p> <pre><code class=javascript>class Employee {
  constructor(name) {
    this._name = name;
  }

  get name() {
    if (this._name) {
      return 'Mr. ' + this._name.toUpperCase();
    } else {
      return undefined;
    }
  }

  set name(newName) {
    if (newName == this._name) {
      console.log('I already have this name.');
    } else if (newName) {
      this._name = newName;
    } else {
      return false;
    }
  }
}

var emp = new Employee('James Bond');

// uses the get method in the background
if (emp.name) {
  console.log(emp.name); // Mr. JAMES BOND
}

// uses the setter in the background
emp.name = 'Bond 007';
console.log(emp.name); // Mr. BOND 007
</code></pre> <p>Latest browsers are also supporting getter/setter functions in Objects and we can use them for computed properties, adding listeners and preprocessing before setting/getting:</p> <pre><code class=javascript>var person = {
  firstName: 'James',
  lastName: 'Bond',
  get fullName() {
    console.log('Getting FullName');
    return this.firstName + ' ' + this.lastName;
  },
  set fullName(name) {
    console.log('Setting FullName');
    var words = name.toString().split(' ');
    this.firstName = words[0] || '';
    this.lastName = words[1] || '';
  },
};

person.fullName; // James Bond
person.fullName = 'Bond 007';
person.fullName; // Bond 007
</code></pre> <p><sup><a href=#table-of-contents>(back to table of contents)</a></sup></p> </article> </div> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <script src=../assets/javascripts/vendor.3636a4ec.min.js></script> <script src=../assets/javascripts/bundle.e9fe3281.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script> <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.5eca75d3.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> </body> </html>
